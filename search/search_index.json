{
    "docs": [
        {
            "location": "/", 
            "text": "Moving to Git\n\n\nWelcome to the learning portal for working with Git as a source control for our Flare documentation.\n\n\nAbout\n\n\nWe designed this website and its content to simplify the learning process of moving to git. Git is not too difficult to learn, but it is very powerful, and it offers us a lot of options in how we manage our source documentation.\n\n\nWe developed the topics on this site by going through different working scenarios while documenting our progress. You can use git via the command line or with a GUI. We recommend that you learn how to use Git Extension, which provides most of the functionality you will need for your daily work.\n\n\nFor basic git functions, you'll find topics written for Git Extension and for Git Bash. The advanced topics are written for Git Extension only. This was due to time, and the likelihood that most people will prefer using Git Extension for most of their work.\n\n\nInfo\nThere may be topics in here that are incomplete and there may be topics that need to be adjusted. This is an ongoing process! Feel free to submit a pull request to improve or change existing documentation.\n\nDownloads\n\n\nYou need to install Git, Git Bash, and Git Extension. You also need to ensure that you have access to the \nqlik-trial\n workspace on git.\n\n\n\n\n\n\nFollow these steps for qlik-trial access\n\n\n\n\n\n\nGet Git\n\n\n\n\n\n\nInstall Git Extensions\n\n\n\n\n\n\nRecommended learning path\n\n\n\n\nLearn the basics\n\n\nClone the repo\n\n\nWorking on a file\n\n\nBranching\n\n\nMerging\n\n\n\n\n\n\nWalk through some examples\n\n\nSimple Workflow using Git Extension\n\n\n\n\n\n\nPlay in the sandbox\n\n\nSandbox project\n\n\n\n\n\n\n\n\nAdditional sources\n\n\nYou can find other useful information here:\n\n\n\n\n\n\n\n\nTitle\n\n\nLink\n\n\n\n\n\n\n\n\n\n\nGit Extension Support\n\n\nGit Extensions\n\n\n\n\n\n\nComplete guide to git\n\n\nThe entire Pro Git book\n\n\n\n\n\n\nThe internet\n\n\nStackoverflow\nIf you have a problem, someone else has likely had that problem...", 
            "title": "Moving to Git"
        }, 
        {
            "location": "/#moving-to-git", 
            "text": "Welcome to the learning portal for working with Git as a source control for our Flare documentation.", 
            "title": "Moving to Git"
        }, 
        {
            "location": "/#about", 
            "text": "We designed this website and its content to simplify the learning process of moving to git. Git is not too difficult to learn, but it is very powerful, and it offers us a lot of options in how we manage our source documentation.  We developed the topics on this site by going through different working scenarios while documenting our progress. You can use git via the command line or with a GUI. We recommend that you learn how to use Git Extension, which provides most of the functionality you will need for your daily work.  For basic git functions, you'll find topics written for Git Extension and for Git Bash. The advanced topics are written for Git Extension only. This was due to time, and the likelihood that most people will prefer using Git Extension for most of their work.  Info There may be topics in here that are incomplete and there may be topics that need to be adjusted. This is an ongoing process! Feel free to submit a pull request to improve or change existing documentation.", 
            "title": "About"
        }, 
        {
            "location": "/#downloads", 
            "text": "You need to install Git, Git Bash, and Git Extension. You also need to ensure that you have access to the  qlik-trial  workspace on git.    Follow these steps for qlik-trial access    Get Git    Install Git Extensions", 
            "title": "Downloads"
        }, 
        {
            "location": "/#recommended-learning-path", 
            "text": "Learn the basics  Clone the repo  Working on a file  Branching  Merging    Walk through some examples  Simple Workflow using Git Extension    Play in the sandbox  Sandbox project", 
            "title": "Recommended learning path"
        }, 
        {
            "location": "/#additional-sources", 
            "text": "You can find other useful information here:     Title  Link      Git Extension Support  Git Extensions    Complete guide to git  The entire Pro Git book    The internet  Stackoverflow If you have a problem, someone else has likely had that problem...", 
            "title": "Additional sources"
        }, 
        {
            "location": "/get-git/", 
            "text": "Get Git\n\n\nTo get set up with Git, you need to download Git and Git Extension.\n\n\n\n\nTip\n\n\nIf you plan to install Git Extension, you can install Git with the Git Extensions installer.\n\n\n\n\nGit\n\n\nYou can download Git from the \nGit Download\n site.\n\n\nThe installer includes:\n\n\n\n\nGit\n\n\nGit bash (CLI for Git)\n\n\n\n\nInfo\nWhen requesting access to qlik-trial, please follow these \ninstructions\n.\nComponents to include during setup\n\n\n\n\nYou can include Git Desktop if you select \nGit GUI Here\n.\n\n\nWe recommend that you use Git Extension instead.\n\n\nGit Extension\n\n\nFollow the instructions to install Git Extension.\n\n\nGit Extension\n\n\nNext steps\n\n\nOnce you have the tools installed on your machine, you should clone the omni-project repository to your machine.\n\n\n\n\n\n\nGet started by cloning the repository with Git Extension\n\n\n\n\nUse Git Extension to clone the omni-project repository to your local machine.\n\n\n\n\n\n\n\n\nGet started by cloning the repository with Git Bash\n\n\n\n\nUse Git Bash to clone the omni-project repository to your local machine.", 
            "title": "Get Git"
        }, 
        {
            "location": "/get-git/#get-git", 
            "text": "To get set up with Git, you need to download Git and Git Extension.   Tip  If you plan to install Git Extension, you can install Git with the Git Extensions installer.", 
            "title": "Get Git"
        }, 
        {
            "location": "/get-git/#git", 
            "text": "You can download Git from the  Git Download  site.  The installer includes:   Git  Git bash (CLI for Git)   Info When requesting access to qlik-trial, please follow these  instructions .", 
            "title": "Git"
        }, 
        {
            "location": "/get-git/#components-to-include-during-setup", 
            "text": "You can include Git Desktop if you select  Git GUI Here .  We recommend that you use Git Extension instead.", 
            "title": "Components to include during setup"
        }, 
        {
            "location": "/get-git/#git-extension", 
            "text": "Follow the instructions to install Git Extension.  Git Extension", 
            "title": "Git Extension"
        }, 
        {
            "location": "/get-git/#next-steps", 
            "text": "Once you have the tools installed on your machine, you should clone the omni-project repository to your machine.    Get started by cloning the repository with Git Extension   Use Git Extension to clone the omni-project repository to your local machine.     Get started by cloning the repository with Git Bash   Use Git Bash to clone the omni-project repository to your local machine.", 
            "title": "Next steps"
        }, 
        {
            "location": "/gitExt-install/", 
            "text": "Git Extension Installation\n\n\nInstalling Git Extension is a quick and simple process.\n\n\nPrerequisites\n\n\n\n\n\n\nMake sure that you have git installed on your computer.\n\n\n\n\nNote\n\n\nIf you don't already have git installed, you can install Git at the same time as your install Git Extension.\n\n\n\n\n\n\n\n\nDownload Git Extension.\n\n\nYou should see the installer in your downloads folder.\n\n\nGit Extension\n\n\n\n\n\n\nInstalling Git Extension\n\n\n\n\n\n\nGrab the latest release from the Git Extensions Github site.\n\n\nThe latest release is v2.51.02. If you scroll down on the page you'll see a green download button.\n\n\nGitExtensions-2.51.01-SetupComplete.exe\n\n\n\n\n\n\nRun the installer.\n\n\n\n\n\n\nSelect the boxes to install Git (if needed) and KDiff (merge conflict tool).\n\n\n\n\nAccept the default install location.\n\n\n\n\n\n\nOn the custom setup dialog, select which features you want to install.\n\n\n\n\n\n\nSelect the SSH Client.\n\n\nI select PuTTY for integration with Windows.\n\n\n\n\n\n\nSelect \nInstall\n.\n\n\nYou will likely get a User Account Control blocking your install. Watch for the blinking icon in your taskbar.\n\n\nYou will also get a KDiff dialog that sits in your task bar that does not automatically pop up. If your install looks to be hanging, check your taskbar for the KDiff install.\n\n\nOnce KDiff installs, your Git Extension installer will finish.\n\n\n\n\n\n\n\n\nInfo\n\n\nThe first time you open Git Extension, the app will verify that your machine is set up correctly. Click \nOK\n to open the app.", 
            "title": "Install Git Extension"
        }, 
        {
            "location": "/gitExt-install/#git-extension-installation", 
            "text": "Installing Git Extension is a quick and simple process.", 
            "title": "Git Extension Installation"
        }, 
        {
            "location": "/gitExt-install/#prerequisites", 
            "text": "Make sure that you have git installed on your computer.   Note  If you don't already have git installed, you can install Git at the same time as your install Git Extension.     Download Git Extension.  You should see the installer in your downloads folder.  Git Extension", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/gitExt-install/#installing-git-extension", 
            "text": "Grab the latest release from the Git Extensions Github site.  The latest release is v2.51.02. If you scroll down on the page you'll see a green download button.  GitExtensions-2.51.01-SetupComplete.exe    Run the installer.    Select the boxes to install Git (if needed) and KDiff (merge conflict tool).   Accept the default install location.    On the custom setup dialog, select which features you want to install.    Select the SSH Client.  I select PuTTY for integration with Windows.    Select  Install .  You will likely get a User Account Control blocking your install. Watch for the blinking icon in your taskbar.  You will also get a KDiff dialog that sits in your task bar that does not automatically pop up. If your install looks to be hanging, check your taskbar for the KDiff install.  Once KDiff installs, your Git Extension installer will finish.     Info  The first time you open Git Extension, the app will verify that your machine is set up correctly. Click  OK  to open the app.", 
            "title": "Installing Git Extension"
        }, 
        {
            "location": "/lfs/", 
            "text": "Git Large File Storage\n\n\nGit is not meant to be a source control repository for large binary files, such as \npng\n, \nsvg\n, and \npptx\n files. In our documentation, we of course include a lot of images. We handle this by using a small program called git lfs. At Qlik, the trunk team has configured git lfs to work with artifactory. Of course, this requires a small set up.\n\n\nWhat is lfs\n\n\nGit lfs lets git indirectly track large binary files by keeping those files in one location (in our case, artifactory), and pointing to them from the git repository. So, git is stil tracking those files but github is not storing those files. This lets us keep the size of the repository under control.\n\n\nSetup\n\n\n\n\nTip\n\n\nYou should install LFS before you clone the repository.\n\n\n\n\nThis is done from the command line.\n\n\n\n\n\n\nDownload git lfs.\n\n\ngit lfs\n\n\n\n\n\n\nOpen git bash (or another terminal).\n\n\ncd\n into the \nhelp-documentation\n on your local machine.\n\n\n\n\n\n\nIn the root directory \nc/git/help-documentation\n, run \ngit lfs install\n.\n\n\n\n\n\n\nNow, log into okta \n artifactory.\n\n\n\n\n\n\nClick your trigram in the top right-hand corner.\n\n\n\n\n\n\nUnder \nAuthentication Settings\n, generate API key.\n\n\nCopy this key to the clip board.\n\n\n\n\n\n\nTest credentials\n\n\n\n\n\n\nFrom the command line, run \ngit pull\n.\n\n\n\n\n\n\nMake sure you are on the \ndaily\n branch. See \nGet the remote branches\n if you haven't yet grabbed the \ndaily\n branch.\n\n\n\n\n\n\nSave any small \npng\n file to your desktop (Google images).\n\n\n\n\n\n\nNow, drag this image file into the root \nhelp-documentation\n folder on your machine (do not add it to content or project).\n\n\n\n\n\n\nRun \ngit status\n to see that git has add the file to your working area.\n\n\n\n\n\n\nRun \ngit add .\n to add the image to the index.\n\n\n\n\n\n\nRun \ngit commit -m \"Adding a test image\"\n to add the image on your branch.\n\n\n\n\n\n\nRun \ngit push\n.\n\n\nSince this is your first time pushing with lfs, you should receive an SSH prompt. Here, enter your trigram and API key (not your password).\n\n\n\n\n\n\nIf the push is successful, you should see something like this:\n\n\nUploading LFS objects: \n100\n% \n(\n1\n/1\n)\n, \n4\n.9 KB \n|\n \n0\n B/s, \ndone\n\nCounting objects: \n3\n, \ndone\n.\nDelta compression using up to \n4\n threads.\nCompressing objects: \n100\n% \n(\n3\n/3\n)\n, \ndone\n.\nWriting objects: \n100\n% \n(\n3\n/3\n)\n, \n379\n bytes \n|\n \n379\n.00 KiB/s, \ndone\n.\nTotal \n3\n \n(\ndelta \n1\n)\n, reused \n0\n \n(\ndelta \n0\n)\n\nremote: Resolving deltas: \n100\n% \n(\n1\n/1\n)\n, completed with \n1\n \nlocal\n object.\nTo https://github.com/qlik-trial/help-documentation.git\n   8acfae3..532fbb8  master -\n master\n\n\n\n\nIf you get something like this:\n\n\nUploading LFS objects:   \n0\n% \n(\n0\n/1\n)\n, \n0\n B \n|\n \n0\n B/s, \ndone\n\nbatch response: Authorization error: https://qliktech.jfrog.io/qliktech/api/lfs/git-lfs/objects/batch\nCheck that you have proper access to the repository\nerror: failed to push some refs to \nhttps://github.com/qlik-trial/help-documentation.git\n\n\n\n\n\nthen you'll need to fix your credential manager.\n\n\nCredential manager\n\n\nArtifactory credential are stored in the windows credential manager, and git uses this to send the api call to artifactory when you run \ngit push\n.\n\n\n\n\n\n\nGo to control panel \n user accounts \n credential manager\n\n\n\n\n\n\nUnder generic credentials, you might see a url that contains \njfrog\n.\n\n\nRemove that if it exists.\n\n\n\n\n\n\nAdd a new generic credential.\n\n\nurl: https://qliktech.jfrog.io/qliktech/api/lfs/git-lfs\n\n\nusername: trigram\n\n\npw: api key (not your Qlik password)\n\n\n\n\n\n\nTry running \ngit push\n again.\n\n\nThis time, a prompt should come up asking for your credentials.\n\n\nNow enter trigram and api key again. This time, your push should work and your credentials should be updated for future pushes.\n\n\n\n\n\n\n\n\nTip\n\n\nIf everything goes well, please delete you image by doing the same thing.\nDelete the image from the local folder.\nRun \ngit add .\n - \ngit commit -m \"removing test image\"\n - \ngit push", 
            "title": "Install Git LFS"
        }, 
        {
            "location": "/lfs/#git-large-file-storage", 
            "text": "Git is not meant to be a source control repository for large binary files, such as  png ,  svg , and  pptx  files. In our documentation, we of course include a lot of images. We handle this by using a small program called git lfs. At Qlik, the trunk team has configured git lfs to work with artifactory. Of course, this requires a small set up.", 
            "title": "Git Large File Storage"
        }, 
        {
            "location": "/lfs/#what-is-lfs", 
            "text": "Git lfs lets git indirectly track large binary files by keeping those files in one location (in our case, artifactory), and pointing to them from the git repository. So, git is stil tracking those files but github is not storing those files. This lets us keep the size of the repository under control.", 
            "title": "What is lfs"
        }, 
        {
            "location": "/lfs/#setup", 
            "text": "Tip  You should install LFS before you clone the repository.   This is done from the command line.    Download git lfs.  git lfs    Open git bash (or another terminal).  cd  into the  help-documentation  on your local machine.    In the root directory  c/git/help-documentation , run  git lfs install .    Now, log into okta   artifactory.    Click your trigram in the top right-hand corner.    Under  Authentication Settings , generate API key.  Copy this key to the clip board.", 
            "title": "Setup"
        }, 
        {
            "location": "/lfs/#test-credentials", 
            "text": "From the command line, run  git pull .    Make sure you are on the  daily  branch. See  Get the remote branches  if you haven't yet grabbed the  daily  branch.    Save any small  png  file to your desktop (Google images).    Now, drag this image file into the root  help-documentation  folder on your machine (do not add it to content or project).    Run  git status  to see that git has add the file to your working area.    Run  git add .  to add the image to the index.    Run  git commit -m \"Adding a test image\"  to add the image on your branch.    Run  git push .  Since this is your first time pushing with lfs, you should receive an SSH prompt. Here, enter your trigram and API key (not your password).    If the push is successful, you should see something like this:  Uploading LFS objects:  100 %  ( 1 /1 ) ,  4 .9 KB  |   0  B/s,  done \nCounting objects:  3 ,  done .\nDelta compression using up to  4  threads.\nCompressing objects:  100 %  ( 3 /3 ) ,  done .\nWriting objects:  100 %  ( 3 /3 ) ,  379  bytes  |   379 .00 KiB/s,  done .\nTotal  3   ( delta  1 ) , reused  0   ( delta  0 ) \nremote: Resolving deltas:  100 %  ( 1 /1 ) , completed with  1   local  object.\nTo https://github.com/qlik-trial/help-documentation.git\n   8acfae3..532fbb8  master -  master  If you get something like this:  Uploading LFS objects:    0 %  ( 0 /1 ) ,  0  B  |   0  B/s,  done \nbatch response: Authorization error: https://qliktech.jfrog.io/qliktech/api/lfs/git-lfs/objects/batch\nCheck that you have proper access to the repository\nerror: failed to push some refs to  https://github.com/qlik-trial/help-documentation.git   then you'll need to fix your credential manager.", 
            "title": "Test credentials"
        }, 
        {
            "location": "/lfs/#credential-manager", 
            "text": "Artifactory credential are stored in the windows credential manager, and git uses this to send the api call to artifactory when you run  git push .    Go to control panel   user accounts   credential manager    Under generic credentials, you might see a url that contains  jfrog .  Remove that if it exists.    Add a new generic credential.  url: https://qliktech.jfrog.io/qliktech/api/lfs/git-lfs  username: trigram  pw: api key (not your Qlik password)    Try running  git push  again.  This time, a prompt should come up asking for your credentials.  Now enter trigram and api key again. This time, your push should work and your credentials should be updated for future pushes.     Tip  If everything goes well, please delete you image by doing the same thing.\nDelete the image from the local folder.\nRun  git add .  -  git commit -m \"removing test image\"  -  git push", 
            "title": "Credential manager"
        }, 
        {
            "location": "/meld/", 
            "text": "Meld\n\n\nMeld is a visual diff and merge tool. Although Git Extension has default integration with KDiff, you can change the default diff/merge tool.\n\n\nInstalling Meld\n\n\n\n\n\n\nGo \nhere\n to download and install the latest version of meld.\n\n\n\n\n\n\nIn Git Extensions, select \nTools\n \n \nSettings\n.\n\n\n\n\n\n\nUnder \nGit Config\n \n \nMergetool\n, select \nmeld\n from the drop-down menu.\n\n\n\n\n\n\nUnder \nGit Config\n \n \nDifftool\n, select \nmeld\n from the drop-down menu.\n\n\nThe configuration should look like this:\n\n\n\n\n\n\n\n\nClick \nApply\n.\n\n\n\n\n\n\nClick \nOk\n.\n\n\n\n\n\n\nUsing Meld\n\n\nWhen a conflict occurs, Git Extensions suggests that you solve the conflict. The tools that Git Extensions will use to resolve the conflict is Meld.\n\n\nUnderstanding the windows\n\n\n\n\nUnderstanding colors\n\n\n\n\n\n\n\n\nColor\n\n\nIndicates\n\n\n\n\n\n\n\n\n\n\nRed\n\n\nLines are in conflict\n\n\n\n\n\n\nBlue\n\n\nResolved conflict lines\n\n\n\n\n\n\nGreen\n\n\nLine modifications that are not in conflict\n\n\n\n\n\n\n\n\n\n\n\n\nSolving the conflict\n\n\nThe goal of the merge tool is to create the correct file in the middle window. You can replace, add, or delete lines using the arrows, or you can edit the content directly in the window.\n\n\nReplace\n\n\nClick an arrow beside colored content to \npush\n it in that direction.\n\n\nIt will replace the content in the adjacent window. This is the default functionality. (In the example below, I clicked on the first arrow on the file located on the right, replacing the content in the file in the middle).\n\n\n\n\nAdd\n\n\nTo add content, hold down \nCtrl\n to turn the arrows into \n+\n signs.\n\n\nClick on the \n+\n sign to add content to the adjacent window.\n\n\nDelete\n\n\nTo delete content, hold down \nShift\n to turn the arrows into \nx\n signs.\n\n\nClick on the \nx\n to delete the content in the adjacent file.\n\n\nLearn more \nhere\n.", 
            "title": "Install Meld"
        }, 
        {
            "location": "/meld/#meld", 
            "text": "Meld is a visual diff and merge tool. Although Git Extension has default integration with KDiff, you can change the default diff/merge tool.", 
            "title": "Meld"
        }, 
        {
            "location": "/meld/#installing-meld", 
            "text": "Go  here  to download and install the latest version of meld.    In Git Extensions, select  Tools     Settings .    Under  Git Config     Mergetool , select  meld  from the drop-down menu.    Under  Git Config     Difftool , select  meld  from the drop-down menu.  The configuration should look like this:     Click  Apply .    Click  Ok .", 
            "title": "Installing Meld"
        }, 
        {
            "location": "/meld/#using-meld", 
            "text": "When a conflict occurs, Git Extensions suggests that you solve the conflict. The tools that Git Extensions will use to resolve the conflict is Meld.", 
            "title": "Using Meld"
        }, 
        {
            "location": "/meld/#understanding-the-windows", 
            "text": "", 
            "title": "Understanding the windows"
        }, 
        {
            "location": "/meld/#understanding-colors", 
            "text": "Color  Indicates      Red  Lines are in conflict    Blue  Resolved conflict lines    Green  Line modifications that are not in conflict", 
            "title": "Understanding colors"
        }, 
        {
            "location": "/meld/#solving-the-conflict", 
            "text": "The goal of the merge tool is to create the correct file in the middle window. You can replace, add, or delete lines using the arrows, or you can edit the content directly in the window.", 
            "title": "Solving the conflict"
        }, 
        {
            "location": "/meld/#replace", 
            "text": "Click an arrow beside colored content to  push  it in that direction.  It will replace the content in the adjacent window. This is the default functionality. (In the example below, I clicked on the first arrow on the file located on the right, replacing the content in the file in the middle).", 
            "title": "Replace"
        }, 
        {
            "location": "/meld/#add", 
            "text": "To add content, hold down  Ctrl  to turn the arrows into  +  signs.  Click on the  +  sign to add content to the adjacent window.", 
            "title": "Add"
        }, 
        {
            "location": "/meld/#delete", 
            "text": "To delete content, hold down  Shift  to turn the arrows into  x  signs.  Click on the  x  to delete the content in the adjacent file.  Learn more  here .", 
            "title": "Delete"
        }, 
        {
            "location": "/get-code/", 
            "text": "Clone the Project with Git Extension\n\n\nGitHub is a web-based platform that hosts git repositories. To start using GitHub, you need to clone our documentation project to your local machine.\n\n\nA clone is local copy of the entire repository, including the repository history. The benefit of having the entire history of the repository on your machine is that you can work locally and offline.\n\n\nGit clone with Git Extension\n\n\nDo the following:\n\n\n\n\nNote\n\n\nThe first time you clone a repository, \nclone a github repository\n appears in the opening dialog.\n\n\n\n\n\n\nGo to \nStart\n \n \nClone repository\n.\n\n\n\n\nEnter the repository URL. You find the URL on the github repository page.\n\n\nIt will be \nhttps://github.com/\nname-of-org\n/\nname-of-repo\n.git\n\n\nThe subdirectory will be created automatically based on the name of the repository.\n\n\nThe destination path should be \nc\\git\n.\n\n\nExample\n\n\n\n\n\n\n\n\nClick \nClone\n when you are ready!\n\n\n\n\n\n\nClick \nOK\n to open the repository.\n\n\nYou should now see the git repository open in in a Git Extension.\n\n\nWhat happened\n\n\nWhen you clone a GitHub repository, you take a copy of the entire repository and save it locally. The local copy is linked to the remote copy (on GitHub).\n\n\nWhy did we do this\n\n\nIn a nutshell, this setup lets you work anywhere, even offline, since you have a copy of the entire history on your local machine. The GitHub repository is no different from your local copy, but for our workflow, we will treat the repository on GitHub as the main repository (the one we want to sync with and push our changes to). You work on your content locally, commit your changes locally, and then push your local changes to the remote repository.", 
            "title": "Clone the Project with Git Extension"
        }, 
        {
            "location": "/get-code/#clone-the-project-with-git-extension", 
            "text": "GitHub is a web-based platform that hosts git repositories. To start using GitHub, you need to clone our documentation project to your local machine.  A clone is local copy of the entire repository, including the repository history. The benefit of having the entire history of the repository on your machine is that you can work locally and offline.", 
            "title": "Clone the Project with Git Extension"
        }, 
        {
            "location": "/get-code/#git-clone-with-git-extension", 
            "text": "Do the following:   Note  The first time you clone a repository,  clone a github repository  appears in the opening dialog.    Go to  Start     Clone repository .   Enter the repository URL. You find the URL on the github repository page.  It will be  https://github.com/ name-of-org / name-of-repo .git  The subdirectory will be created automatically based on the name of the repository.  The destination path should be  c\\git .  Example     Click  Clone  when you are ready!    Click  OK  to open the repository.  You should now see the git repository open in in a Git Extension.", 
            "title": "Git clone with Git Extension"
        }, 
        {
            "location": "/get-code/#what-happened", 
            "text": "When you clone a GitHub repository, you take a copy of the entire repository and save it locally. The local copy is linked to the remote copy (on GitHub).", 
            "title": "What happened"
        }, 
        {
            "location": "/get-code/#why-did-we-do-this", 
            "text": "In a nutshell, this setup lets you work anywhere, even offline, since you have a copy of the entire history on your local machine. The GitHub repository is no different from your local copy, but for our workflow, we will treat the repository on GitHub as the main repository (the one we want to sync with and push our changes to). You work on your content locally, commit your changes locally, and then push your local changes to the remote repository.", 
            "title": "Why did we do this"
        }, 
        {
            "location": "/get-code-cli/", 
            "text": "Clone the Project with Git Bash\n\n\nGitHub is a web-based platform that hosts git repositories. To start using GitHub, you need to clone our documentation project to your local machine.\n\n\nA clone is local copy of the entire repository, including the repository history. The benefit of having the entire history of the repository on your machine is that you can work locally and offline.\n\n\nTip\nNeed some help getting started with Git Bash?\n\n\nTips for using Git Bash\nClone the repo using Git Bash\n\n\nBefore we clone, we create a git folder on our machine (if you don't already have one).\n\n\n\n\nCreate a new directory called \ngit\n on your machine.\n    \nC:\n\\g\nit\n\n\n\nOpen Git Bash.\n\n\n\n\nGo to the \ngit\n directory you just created.\n\n\ncd\n ../../c/git\n\n\n\n\nInfo\nWhen you first open Git Bash you are in the Home directory, so you probably need to move up two directories.\n\n\n\n\nClone the omni project\n\n\ncd\n c/git/\ngit clone https://github.com/qlik-trial/omni-project.git .\n\n\n\n\nFirst, you \ncd\n to the directory where you want to set up your local copy. This should be \nc/git\n. The (.) at the end tells git to use the current folder as the checkout folder.\n\n\n\n\n\n\nThe omni-project is now cloned to your local machine.\n\n\n\n\n\n\nRun the following command from Git Bash:\n\n\ncd omni-project\n\n\nYour current directory is the omni-project git repository. You should see (master) at the end of your directory path in Git Bash. Like this:\n\n\nBDM@usott-bdm MINGW64 /c/git/omni-project \n(\nmaster\n)\n\n\n\n5. Check the status of the repo (just for fun, and it's always good to know the status of a branch).\n\n\ngit status\n\n\n\n\n\n\n\n\nYou now have a local copy of the repository that is being tracked by the remote \nGitHub\n repository.", 
            "title": "Clone the Project with Git Bash"
        }, 
        {
            "location": "/get-code-cli/#clone-the-project-with-git-bash", 
            "text": "GitHub is a web-based platform that hosts git repositories. To start using GitHub, you need to clone our documentation project to your local machine.  A clone is local copy of the entire repository, including the repository history. The benefit of having the entire history of the repository on your machine is that you can work locally and offline.  Tip Need some help getting started with Git Bash?  Tips for using Git Bash", 
            "title": "Clone the Project with Git Bash"
        }, 
        {
            "location": "/get-code-cli/#clone-the-repo-using-git-bash", 
            "text": "Before we clone, we create a git folder on our machine (if you don't already have one).   Create a new directory called  git  on your machine.\n     C: \\g it  Open Git Bash.   Go to the  git  directory you just created.  cd  ../../c/git  Info When you first open Git Bash you are in the Home directory, so you probably need to move up two directories.   Clone the omni project  cd  c/git/\ngit clone https://github.com/qlik-trial/omni-project.git .  First, you  cd  to the directory where you want to set up your local copy. This should be  c/git . The (.) at the end tells git to use the current folder as the checkout folder.    The omni-project is now cloned to your local machine.    Run the following command from Git Bash:  cd omni-project \nYour current directory is the omni-project git repository. You should see (master) at the end of your directory path in Git Bash. Like this:  BDM@usott-bdm MINGW64 /c/git/omni-project  ( master )  \n5. Check the status of the repo (just for fun, and it's always good to know the status of a branch).  git status    You now have a local copy of the repository that is being tracked by the remote  GitHub  repository.", 
            "title": "Clone the repo using Git Bash"
        }, 
        {
            "location": "/remote/", 
            "text": "Pulling a remote branch\n\n\nWhen you clone the \nhelp-documentationn\n repo, whether it be with git bash or Git Extension, you'll only see a \nmaster\n branch. Our daily work will be merged to the \ndaily\n branch, so you need to make sure that you pull this branch from the remote to your local machine.\n\n\nGit Extension\n\n\n\n\n\n\nSelect \nView\n \n \nShow remote branches\n.\n\n\nYou'll see the \norigin/daily\n somewhere in the graph.\n\n\n\n\n\n\nClick the branch drop-down and select \nCheckout branch\n.\n\n\n\n\nA dialog opens.\n\n\n\n\n\n\nMake sure to use the following selections:\n\n\n\n\n\n\n\n\nSelect \nCheckout\n.\n\n\nYou will now have a local copy of the \ndaily\n branch.\n\n\n\n\n\n\n\n\nInfo\n\n\nRemember that you should always pull the latest from \ndaily\n before you create local feature branches. Always pull latest from \ndaily\n before merging your feature branch to \ndaily\n.\n\n\n\n\nGit bash\n\n\nRun the following commands from the \nhelp-documentation\n repo:\n\n\n\n\n\n\nList the branches. You will see your local and remote branches.\n\n\n/c/git/help-documentation \n(\nmaster\n)\n\n$ git branch --all\n* master\nremotes/origin/HEAD -\n origin/master\nremotes/origin/daily\nremotes/origin/master\n\n\n\n\n\n\n\n\nCheckout \ndaily\n. By checking it out, git creates a local branch and sets upstream tracking.\n\n\n/c/git/help-documentation \n(\nmaster\n)\n\n$ git checkout daily\nSwitched to a new branch \ndaily\n\nBranch \ndaily\n \nset\n up to track remote branch \ndaily\n from \norigin\n.\n\n/c/git/help-documentation \n(\ndaily\n)\n\n$ git status\nOn branch daily\nYour branch is up to date with \norigin/daily\n.\n\nnothing to commit, working tree clean\n\n\n\n\n\n\n\n\nCheck the log. This will show you where \ndaily\n is relative to the commit history. The -3 argument tells git to show the last 3 commits. Set this number to anything.\n\n\n/c/git/help-documentation \n(\ndaily\n)\n\n$ git log --branches --oneline -3\n0d6da15f \n(\nHEAD -\n daily, origin/master, origin/daily, origin/HEAD, master\n)\n Merge branch \nmaster\n of https://github.com/qlik-trial/help-documentation\ne4475d8c Condition cleanup\nf0cb3326 Merge branch \nmaster\n of https://github.com/qlik-trial/help-documentation\n\n\n\n\n\n\n\n\nVerify.\n\n\n/c/git/help-documentation \n(\ndaily\n)\n\n$ git branch\n* daily\nmaster\n\n\n\n\n\n\n\n\n\n\nInfo\n\n\nRemember that you should always pull the latest from \ndaily\n before you create local feature branches. Always pull latest from \ndaily\n before merging your feature branch to \ndaily\n.", 
            "title": "Get the remote branches"
        }, 
        {
            "location": "/remote/#pulling-a-remote-branch", 
            "text": "When you clone the  help-documentationn  repo, whether it be with git bash or Git Extension, you'll only see a  master  branch. Our daily work will be merged to the  daily  branch, so you need to make sure that you pull this branch from the remote to your local machine.", 
            "title": "Pulling a remote branch"
        }, 
        {
            "location": "/remote/#git-extension", 
            "text": "Select  View     Show remote branches .  You'll see the  origin/daily  somewhere in the graph.    Click the branch drop-down and select  Checkout branch .   A dialog opens.    Make sure to use the following selections:     Select  Checkout .  You will now have a local copy of the  daily  branch.     Info  Remember that you should always pull the latest from  daily  before you create local feature branches. Always pull latest from  daily  before merging your feature branch to  daily .", 
            "title": "Git Extension"
        }, 
        {
            "location": "/remote/#git-bash", 
            "text": "Run the following commands from the  help-documentation  repo:    List the branches. You will see your local and remote branches.  /c/git/help-documentation  ( master ) \n$ git branch --all\n* master\nremotes/origin/HEAD -  origin/master\nremotes/origin/daily\nremotes/origin/master    Checkout  daily . By checking it out, git creates a local branch and sets upstream tracking.  /c/git/help-documentation  ( master ) \n$ git checkout daily\nSwitched to a new branch  daily \nBranch  daily   set  up to track remote branch  daily  from  origin .\n\n/c/git/help-documentation  ( daily ) \n$ git status\nOn branch daily\nYour branch is up to date with  origin/daily .\n\nnothing to commit, working tree clean    Check the log. This will show you where  daily  is relative to the commit history. The -3 argument tells git to show the last 3 commits. Set this number to anything.  /c/git/help-documentation  ( daily ) \n$ git log --branches --oneline -3\n0d6da15f  ( HEAD -  daily, origin/master, origin/daily, origin/HEAD, master )  Merge branch  master  of https://github.com/qlik-trial/help-documentation\ne4475d8c Condition cleanup\nf0cb3326 Merge branch  master  of https://github.com/qlik-trial/help-documentation    Verify.  /c/git/help-documentation  ( daily ) \n$ git branch\n* daily\nmaster     Info  Remember that you should always pull the latest from  daily  before you create local feature branches. Always pull latest from  daily  before merging your feature branch to  daily .", 
            "title": "Git bash"
        }, 
        {
            "location": "/working-gitExt/", 
            "text": "Working on a file in Git Extension\n\n\nThe majority of our work involves creating and editing individual files. Git Extension helps us do most of this work.\n\n\nSee the changes to a file\n\n\nWhen you start to edit a file in a git repo, git keeps tracks of the changes.\n\n\nLook at the image below. The second menu bar at the top indicates that we have \nCommit (1)\n, telling us that we have one uncommited change.\n\n\n\n\nStage the file and/or changes\n\n\nFiles in git are in one of three states:\n\n\n\n\nunstaged\n (they are modified and in the working area)\n\n\nstaged\n (they are staged and in the index)\n\n\ncommitted\n (they have been added to the repository)\n\n\n\n\nGit Extension lets you stage the entire file, or you can select pieces of a file to stage as \nhunks\n.\n\n\nWhy would you want to stage a file in hunks?\n\n\n\n\nYou might want to append a commit message to a subset of the changes.\n\n\nYou may want to commit small pieces so you can reverse-commit small changes (if needed).\n\n\nIf it works for your workflow, then do it!\n\n\n\n\nStage\n\n\n\n\n\n\nTo stage changes, click the \nCommit (X)\n button in the Git Extension task bar.\n\n\nA dialog opens.\n\n\n\n\n\n\nSelect the file you want to stage. You can select multiple files by holding down CTRL while selecting files.\n\n\nUse the down arrows to stage a file or stage all, and use the up arrows to unstage a file or unstage all.\n\n\n\n\n\n\n\n\nStage hunks\n\n\nIf you are working on a file and have many added/removed lines, you can stage hunks.\n\n\n\n\n\n\nRight click the line you want to stage and select \nStage select line\n.\n\n\n\n\n\n\nOr, highlight a section (multiple lines) to stage more than one line.\n\n\nWhen you stage hunks, make sure to select the add/remove equivalent. For example, line 1 changed by adding the encoding UTF=8. Make sure to stage both the line highlighted in red and that line 1 highlighted in green.\n\n\n\n\nTip\nAlways stage \nadded\n and \nremoved\n lines together. If you don't, you'll end up with conflicts in the files.\n\n\n\n\nCommit file changes to a branch\n\n\nAfter you stage individual files, hunks, or lines, you then commit those staged files to the branch. When you commit, all \nstaged\n files (files that are added to the index) are included in the commit.\n\n\n\n\n\n\nWrite a message in the commit message area.\n\n\n\n\n\n\nClick \nCommit\n.\n\n\nFeature branches are not tracked on GitHub so we don't need to push changes. If you are commiting directly to a shared branch then you can select \nCommit \n push\n.\n\n\n\n\n\n\n\n\nAfter you commit the changes to the branch, the Git Extension graph will show the newest commit at the top with the message that you added.\n\n\n\n\nMore on branches in the \nbranching\n section.\n\n\nStash file changes for later\n\n\nGit Extension helps you stash file changes so you can access them later. For example, at the end of the day, you have made a bunch of changes to a topic, but you don't want to commit these changes to a branch just yet. You can save the state of the file as a \nstash\n that you can retrieve later.\n\n\nStashing moves to files out of your working area and the index, and saves them to an area called \nstash\n. This lets you work on other files without losing the changes you've already made, and it keeps them out of the way so you don't accidentally stage them with some other work.\n\n\nTo stash changes:\n\n\n\n\n\n\nLeave the changes in your working area (the can be in the index too, but BP says to have them in your working area).\n\n\n\n\n\n\nFrom the main Git Extension dialog, click \nCommands\n from the top task menu.\n\n\nA dialog opens.\n\n\n\n\n\n\nIf you are working on other files and they are added to the index, select the \nKeep Index\n box.\n\n\n\n\n\n\nIf the files are new (not yet tracked in the repository) select \nInclude untracked\n.\n\n\n\n\n\n\nSelect \nSave Changes to New Stash\n.\n\n\nThe stash is saved to the stash dialog window under \nWIP \nbranch\n \nfile\n.\n\n\n\n\n\n\nNow I want to bring my stash back into the working area.\n\n\n\n\n\n\nClick \nCommands\n \n \nStash Changes\n.\n\n\nA dialog opens.\n\n\n\n\n\n\n\n\nSelect the stash, then \nApply Select Stash\n to apply the stash to the current branch.\n\n\nThe graph will show that the index has been added and there will be a pending commit.\n\n\n\n\n\n\n\n\nCommit the changes as normal.\n\n\nIf you do not need to keep the stash, select the option \nDrop Selected Stash\n.\n\n\n\n\n\n\nRecommit previous file versions\n\n\nIt can be useful to be able to quickly see the state of a file at any point along the branch history and to change a file back to this state. You can do this by viewing the history of a file and revert the commit.\n\n\n\n\n\n\nUse the \nFile Tree\n to see the file history.\n\n\nRight-click the file and select \nView History\n.\n\n\n\n\nA dialog opens.\n\n\n\n\nAt the top, you can see which file history you are looking at.\n\n\nSelect commits in the graph to see the version of that file at that commit.\n\n\nThe \nDiff\n tab shows you how that file looked at that commit.\n\n\n\n\n\n\nWhen you find the file version you want, right-click the \ncommit\n that has that version.\n\n\nSelect \nManipulate commit\n \n \nRevert commit\n.\n\n\n\n\nWarning\n\n\nMake sure \nAutomatically create a commit\n is deselected.\n\n\n\n\n\n\n\n\nWhen you go back to the main window, you'll see a number beside the commit button. The files associated with the commit you are reverting are in the index.\n\n\n\n\n\n\nUnstage the files that you don't want to revert.\n\n\n\n\n\n\nLeave a commit message and select \nCommit\n.\n\n\nA new commit is added to the top of the graph that reverts the files to the previous version.\n\n\n\n\n\n\n\n\nInfo\n\n\nIf there were more than one file associated with a commit, those files are added back into the working area. After you commit the file you want to revert, just discard the files in the working area. \n\n\nRight-click the files and select \nReset files or directory changes\n.", 
            "title": "Working on a File in Git Extension"
        }, 
        {
            "location": "/working-gitExt/#working-on-a-file-in-git-extension", 
            "text": "The majority of our work involves creating and editing individual files. Git Extension helps us do most of this work.", 
            "title": "Working on a file in Git Extension"
        }, 
        {
            "location": "/working-gitExt/#see-the-changes-to-a-file", 
            "text": "When you start to edit a file in a git repo, git keeps tracks of the changes.  Look at the image below. The second menu bar at the top indicates that we have  Commit (1) , telling us that we have one uncommited change.", 
            "title": "See the changes to a file"
        }, 
        {
            "location": "/working-gitExt/#stage-the-file-andor-changes", 
            "text": "Files in git are in one of three states:   unstaged  (they are modified and in the working area)  staged  (they are staged and in the index)  committed  (they have been added to the repository)   Git Extension lets you stage the entire file, or you can select pieces of a file to stage as  hunks .  Why would you want to stage a file in hunks?   You might want to append a commit message to a subset of the changes.  You may want to commit small pieces so you can reverse-commit small changes (if needed).  If it works for your workflow, then do it!", 
            "title": "Stage the file and/or changes"
        }, 
        {
            "location": "/working-gitExt/#stage", 
            "text": "To stage changes, click the  Commit (X)  button in the Git Extension task bar.  A dialog opens.    Select the file you want to stage. You can select multiple files by holding down CTRL while selecting files.  Use the down arrows to stage a file or stage all, and use the up arrows to unstage a file or unstage all.", 
            "title": "Stage"
        }, 
        {
            "location": "/working-gitExt/#stage-hunks", 
            "text": "If you are working on a file and have many added/removed lines, you can stage hunks.    Right click the line you want to stage and select  Stage select line .    Or, highlight a section (multiple lines) to stage more than one line.  When you stage hunks, make sure to select the add/remove equivalent. For example, line 1 changed by adding the encoding UTF=8. Make sure to stage both the line highlighted in red and that line 1 highlighted in green.   Tip Always stage  added  and  removed  lines together. If you don't, you'll end up with conflicts in the files.", 
            "title": "Stage hunks"
        }, 
        {
            "location": "/working-gitExt/#commit-file-changes-to-a-branch", 
            "text": "After you stage individual files, hunks, or lines, you then commit those staged files to the branch. When you commit, all  staged  files (files that are added to the index) are included in the commit.    Write a message in the commit message area.    Click  Commit .  Feature branches are not tracked on GitHub so we don't need to push changes. If you are commiting directly to a shared branch then you can select  Commit   push .     After you commit the changes to the branch, the Git Extension graph will show the newest commit at the top with the message that you added.   More on branches in the  branching  section.", 
            "title": "Commit file changes to a branch"
        }, 
        {
            "location": "/working-gitExt/#stash-file-changes-for-later", 
            "text": "Git Extension helps you stash file changes so you can access them later. For example, at the end of the day, you have made a bunch of changes to a topic, but you don't want to commit these changes to a branch just yet. You can save the state of the file as a  stash  that you can retrieve later.  Stashing moves to files out of your working area and the index, and saves them to an area called  stash . This lets you work on other files without losing the changes you've already made, and it keeps them out of the way so you don't accidentally stage them with some other work.  To stash changes:    Leave the changes in your working area (the can be in the index too, but BP says to have them in your working area).    From the main Git Extension dialog, click  Commands  from the top task menu.  A dialog opens.    If you are working on other files and they are added to the index, select the  Keep Index  box.    If the files are new (not yet tracked in the repository) select  Include untracked .    Select  Save Changes to New Stash .  The stash is saved to the stash dialog window under  WIP  branch   file .    Now I want to bring my stash back into the working area.    Click  Commands     Stash Changes .  A dialog opens.     Select the stash, then  Apply Select Stash  to apply the stash to the current branch.  The graph will show that the index has been added and there will be a pending commit.     Commit the changes as normal.  If you do not need to keep the stash, select the option  Drop Selected Stash .", 
            "title": "Stash file changes for later"
        }, 
        {
            "location": "/working-gitExt/#recommit-previous-file-versions", 
            "text": "It can be useful to be able to quickly see the state of a file at any point along the branch history and to change a file back to this state. You can do this by viewing the history of a file and revert the commit.    Use the  File Tree  to see the file history.  Right-click the file and select  View History .   A dialog opens.   At the top, you can see which file history you are looking at.  Select commits in the graph to see the version of that file at that commit.  The  Diff  tab shows you how that file looked at that commit.    When you find the file version you want, right-click the  commit  that has that version.  Select  Manipulate commit     Revert commit .   Warning  Make sure  Automatically create a commit  is deselected.     When you go back to the main window, you'll see a number beside the commit button. The files associated with the commit you are reverting are in the index.    Unstage the files that you don't want to revert.    Leave a commit message and select  Commit .  A new commit is added to the top of the graph that reverts the files to the previous version.     Info  If there were more than one file associated with a commit, those files are added back into the working area. After you commit the file you want to revert, just discard the files in the working area.   Right-click the files and select  Reset files or directory changes .", 
            "title": "Recommit previous file versions"
        }, 
        {
            "location": "/working-gitbash/", 
            "text": "Working on a file with Git Bash\n\n\nThe majority of our work involves creating and editing individual files. We can use Git Bash to do things like see file changes, stage files, commit files, and stash changes.\n\n\nPrerequisites\n\n\nYou should be familiar with the basic git commands using Git Bash.\n\n\n\n\nTips for using Git Bash\n\n\n\n\nEither before of after, and to use as a reference anytime, the cheat sheet is a quick walk through of the basic Git Bash commands.\n\n\n\n\nGit Bash Cheat Sheet\n\n\n\n\nTip\nIf Git Bash goes into interactive shell mode when you are running the commands on this page, you can type \nq\n then hit \nEnter\n to return to the command shell. If you enter vim (the shell-bashed text editor), hit \nesc\n then type \nx\n, then hit \nenter\n.\nSee the changes to a file\n\n\nWhen you start to edit a file in a git repo, git keeps tracks of the change and places the file in an \nunstaged\n state.\n\n\n\n\nRun: \ngit status\n\n\n\n\ngit status\nOn branch master\nYour branch is up to date with \norigin/master\n.\n\nChanges not staged \nfor\n commit:\n  \n(\nuse \ngit add \nfile\n...\n to update what will be committed\n)\n\n  \n(\nuse \ngit checkout -- \nfile\n...\n to discard changes in working directory\n)\n\n\n        modified:   text.md\n\nno changes added to commit \n(\nuse \ngit add\n and/or \ngit commit -a\n)\n\n\n\n\n\nBeside \nmodified\n, git lists the files that have changed. We can see the difference in Git Bash.\n\n\n\n\nRun: \ngit diff \nfile-name\n\n\n\n\ngit diff text.md\ndiff --git a/text.md b/text.md\nindex a791549..818c005 \n100644\n\n--- a/text.md\n+++ b/text.md\n@@ -1,9 +1,4 @@\n-# Title\n+# Gaius Marius\n\n\n\n\nGit shows the difference of \nunstaged\n files relative to the index (the current file version on git). In other words, git shows what changes can be added to the index.\n\n\nThe change is shown like this:\n\n\n-# Title\n+# Gaius Marius\n\n\n\n\n\"# Title\" is removed and \"# Gaius Marius\" is added.\n\n\nStage the file and/or changes\n\n\nFiles in git are in one of three states:\n\n\n\n\nunstaged\n (they are being worked on - not in index)\n\n\nstaged\n (they are ready to be committed - added to index)\n\n\ncommitted\n (they have been pushed to a branch - committed to branch)\n\n\n\n\nWhen you make changes to a file or files, git tracks those files and their chages.\n\n\nRun: \ngit status\n\n\ngit status\nOn branch master\nYour branch is up to date with \norigin/master\n.\n\nChanges not staged for commit:\n  (use \ngit add \nfile\n...\n to update what will be committed)\n  (use \ngit checkout -- \nfile\n...\n to discard changes in working directory)\n\n        modified:   text.md\n        modified:   text_3.md\n\nno changes added to commit (use \ngit add\n and/or \ngit commit -a\n)\n\n\n\n\nSo far, I've change two files. They appear beside modified, and they should be highlighted in red in your Git Bash shell.\n\n\nmodified:   text.md\nmodified:   text_3.md\n\n\n\n\nStage all\n\n\nIf you have many files to stage, use a shorthand command to stage all.\n\n\nRun \ngit add .\n or \ngit add --all\n or \ngit add -A\n. Stage individual files with \ngit add \nfile\n.\n\n\ngit add --all\ngit status\n\n\n\n\nThe previously \nunstaged\n files are now \nstaged\n and they appear in green.\n\n\nTo \nunstage\n the newly \nstaged\n files, run \ngit reset\n or \ngit reset HEAD \nfile\n to unstage a specific file.\n\n\ngit reset HEAD text.md\ngit reset HEAD text_3.md\n\n\n\n\nStage hunks\n\n\nYou can stage a subset of the file by staging hunks. You can do this with the \ngit add -p\n or \ngit add --patch\n command. Git determines hunks by proximity/distance. Changes that are close together are \nhunked\n together.\n\n\nFirst, run \ngit status\n to see your \nunstaged\n files, then run \ngit add -p \nfile-name\n to open the \ndiff\n in Git Bash. Git will show you each hunk and ask you what to do in interactive shell mode.\n\n\nIf Git calculates multiple hunks, Git will show you one hunk at a time. After the hunk, Git gives the following options:\n\n\n\n\n\n\n\n\nOption\n\n\nWhat it does\n\n\n\n\n\n\n\n\n\n\ny\n\n\nYes, stage this hunk.\n\n\n\n\n\n\nn\n\n\nNo, don't stage this hunk.\n\n\n\n\n\n\nq\n\n\nQuit, clear this command.\n\n\n\n\n\n\na\n\n\nStage this and all hunks.\n\n\n\n\n\n\nd\n\n\nDon't stage this or any hunks.\n\n\n\n\n\n\n/\n\n\nSearch for a hunk given a regex.\n\n\n\n\n\n\ne\n\n\nEdit the current hunk.\n\n\n\n\n\n\n?\n\n\nPrint help\n\n\n\n\n\n\n\n\nSay that I only want to commit one hunk, not the other. I type \ny\n then hit \nEnter\n to stage the first hunk. Then I type \nn\n, then hit \nEnter\n to not stage the second hunk. Now, when I run \ngit status\n, I see the same file in both \nunstaged\n (Changes to be committed) and \nstaged\n (Changes not staged for commit) states. This represents the two hunks of the same file.\n\n\ngit status\nOn branch master\nYour branch is ahead of \norigin/master\n by \n1\n commit.\n  \n(\nuse \ngit push\n to publish your \nlocal\n commits\n)\n\n\nChanges to be committed:\n  \n(\nuse \ngit reset HEAD \nfile\n...\n to unstage\n)\n\n\n        modified:   README.md\n\nChanges not staged \nfor\n commit:\n  \n(\nuse \ngit add \nfile\n...\n to update what will be committed\n)\n\n  \n(\nuse \ngit checkout -- \nfile\n...\n to discard changes in working directory\n)\n\n\n        modified:   README.md\n\n\n\n\nThe reason to do this might be to have a specific changeset associated with a single commit. This is useful when you want to reverse commit some changes or you want a more granular and focused commit history.\n\n\nSplit hunks with patch\n\n\nIf you have a file that you want to stage in hunks, but it only shows you one hunk, you can force a split.\n\n\nAfter running \ngit add -p \nfile-name\n, print the patch help by entering \n?\n option. Notice that you have more options than what's displayed.\n\n\ns - split the current hunk into smaller hunk\n\n\nEnter \ns\n and press enter. If git is able to automatically split the hunk, it will. If the hunk cannot be split, you'll have to do this manually with a GUI like Sourcetree (or read the git documentation to do this manually with Git Bash: \nGit Tools - Interactive Staging\n).\n\n\nInfo\nI am not documenting splitting hunks with Git Bash because it is much easier just to use Sourcetree. \nSee how you can do this with a GUI: \nStage the file and/or changes\n.\nCommit file changes to a branch\n\n\nYour files are staged, now you commit.\n\n\nRun \ngit commit\n to commit the changes.\n\n\ngit commit -m \nsome message\n\n\n\n\n\nUse the \n-m\n flag to add a commit message. Messages should be succinct and useful. Include the JIRA if possible.\n\n\nRun \ngit status\n.\n\n\nIf you've staged and committed all of the tracked files, you'll notice that when you run \ngit status\n there is nothing to commit but that you are ahead of \norigin/master\n.\n\n\ngit status\nOn branch master\nYour branch is ahead of \norigin/master\n by \n1\n commit.\n  \n(\nuse \ngit push\n to publish your \nlocal\n commits\n)\n\n\nnothing to commit, working tree clean\n\n\n\n\nYou need to push your changes to the remote. If your branch is tracked upstream, run \ngit push\n.\n\n\nIf you do not yet have an upstream branch, you'll have to set the upstream remote.\n\n\ngit push -u origin \nbranch-name\n\n\n\n\n\nor\n\n\ngit push --set-upstream origin \nbranch-name\n\n\n\n\n\nTo learn about branching, and tracking branches upstream, see: \nBranching with Git Bash\n.\n\n\nStash file changes for later\n\n\nYou can stash changes to a file with the \ngit stash\n command. Stash stores the changes to a file and the index, and returns to a clean working directory. This is helpful when you are making changes to a file that you do not yet want to commit to a branch, but that you don't want to lose.\n\n\nThere are a couple ways to do this. If we have a single file that has changes, we can stage and then stash.\n\n\ngit add \nfile\n\ngit stash save \nA good stash message\n\n\n\nThis creates a stash with the appended message and returns your index to a clean state.\n\n\nRun \ngit status\n to see that the \nstaged\n file is no longer there.\n\n\nRun \ngit stash list\n to see your stash.\n\n\ngit stash list\nstash@\n{\n0\n}\n: On master: a good stash message\n\n\n\n\nYou can create as many stashes as you want.\n\n\nIf I make another change to the file and stash it again, see what happens.\n\n\ngit stash list\nstash@\n{\n0\n}\n: On master: another really good stash message\nstash@\n{\n1\n}\n: On master: a good stash message\n\n\n\n\nNotice that the first stash changed its index: stash@{1}. This is a zero-based index which means that 0 is the first item in the index.\n\n\nTo apply a stash, use \ngit stash apply\n\n\nNow, we have two stashes in the index: 0 and 1.\n\n\ngit apply\n by default applies the stash at the top of the index. When you apply a stash, it is brought back into the working directory in an \nunstaged\n state. You need to run \ngit add\n to stage it and \ngit commit\n to commit it.\n\n\ngit apply\n does not delete the stash, so it remains in the index.\n\n\ngit stash pop\n applies the top stash and deletes it.\n\n\nYou can select the stash to apply by specifying the index.\n\n\ngit stash apply stash@\n{\n1\n}\n\n\n\n\n\nThis would apply the second stash, at index position 1.\n\n\nTo force delete a stash, use \ngit stash drop stash@{index}\n.\n\n\nTo delete all stashes, use \ngit stash clear\n.\n\n\nRecommit a file to a previous version\n\n\nSometimes you need to return a file to a previous version. You can do this with Git Bash by restoring a specific file to the state it was in for a given commit.\n\n\nYou need to take several steps:\n\n\n\n\nFind the commit hash that you want to restore.\n\n\nCheck the file.\n\n\nCheckout the file from that commit.\n\n\nCommit the file again.\n\n\n\n\nFind the commit hash\n\n\nYou can see a quick commit history by running \ngit log\n. This command returns a list of commits and their SHA1s, dates, and commit messages. You might want to see a history for a specific file rather than the commit history of a branch. Run the following command to get a file history for a specific file.\n\n\ngit log -p -- \nfile-name\n\n\n\n\n\nYou'll see a commit history with the file changes at each commit\n\n\nIf the file has been renamed, use the \n--follow\n flag to track a file across name changes.\n\n\ngit log --follow -p -- \nfile-name\n\n\n\n\n\nWhen you see the commit you want to recommit, copy the first 6 digits of the SHA1.\n\n\nCheck the file\n\n\nTo see all of the file changes at a commit, use \ngit diff\n.\n\n\ngit diff -p \nhash\n -- \nfile-name\n\n\n\n\n\nThe \n-p\n flag prints the patches (the changes) for the file at the specific commit \nhash>.\nYou'll see the patches for the named file for the specified commit.\n\n\nYou can see the state of the file (what the file looked like) at this commit wit \ngit show\n.\n\n\ngit show \nhash\n:\nfile-name\n\n\n\n\n\nYou'll see the state of the file at this commit. You won't see what patches are associated with the commit.\n\n\nCheckout and recommit\n\n\nTo restore the file to a previous version, run the following commands.\n\n\ngit checkout \nhash\n -- \nfile-name\n\ngit add \nfile-name\n\ngit commit -m \nrestoring \nfile-name\n to previous commit\n\ngit push\n\n\n\n\nIf you run \ngit log\n again, your new commit will appear at the top.", 
            "title": "Working on a File with Git Bash"
        }, 
        {
            "location": "/working-gitbash/#working-on-a-file-with-git-bash", 
            "text": "The majority of our work involves creating and editing individual files. We can use Git Bash to do things like see file changes, stage files, commit files, and stash changes.", 
            "title": "Working on a file with Git Bash"
        }, 
        {
            "location": "/working-gitbash/#prerequisites", 
            "text": "You should be familiar with the basic git commands using Git Bash.   Tips for using Git Bash   Either before of after, and to use as a reference anytime, the cheat sheet is a quick walk through of the basic Git Bash commands.   Git Bash Cheat Sheet   Tip If Git Bash goes into interactive shell mode when you are running the commands on this page, you can type  q  then hit  Enter  to return to the command shell. If you enter vim (the shell-bashed text editor), hit  esc  then type  x , then hit  enter .", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/working-gitbash/#see-the-changes-to-a-file", 
            "text": "When you start to edit a file in a git repo, git keeps tracks of the change and places the file in an  unstaged  state.   Run:  git status   git status\nOn branch master\nYour branch is up to date with  origin/master .\n\nChanges not staged  for  commit:\n   ( use  git add  file ...  to update what will be committed ) \n   ( use  git checkout --  file ...  to discard changes in working directory ) \n\n        modified:   text.md\n\nno changes added to commit  ( use  git add  and/or  git commit -a )   Beside  modified , git lists the files that have changed. We can see the difference in Git Bash.   Run:  git diff  file-name   git diff text.md\ndiff --git a/text.md b/text.md\nindex a791549..818c005  100644 \n--- a/text.md\n+++ b/text.md\n@@ -1,9 +1,4 @@\n-# Title\n+# Gaius Marius  Git shows the difference of  unstaged  files relative to the index (the current file version on git). In other words, git shows what changes can be added to the index.  The change is shown like this:  -# Title\n+# Gaius Marius  \"# Title\" is removed and \"# Gaius Marius\" is added.", 
            "title": "See the changes to a file"
        }, 
        {
            "location": "/working-gitbash/#stage-the-file-andor-changes", 
            "text": "Files in git are in one of three states:   unstaged  (they are being worked on - not in index)  staged  (they are ready to be committed - added to index)  committed  (they have been pushed to a branch - committed to branch)   When you make changes to a file or files, git tracks those files and their chages.  Run:  git status  git status\nOn branch master\nYour branch is up to date with  origin/master .\n\nChanges not staged for commit:\n  (use  git add  file ...  to update what will be committed)\n  (use  git checkout --  file ...  to discard changes in working directory)\n\n        modified:   text.md\n        modified:   text_3.md\n\nno changes added to commit (use  git add  and/or  git commit -a )  So far, I've change two files. They appear beside modified, and they should be highlighted in red in your Git Bash shell.  modified:   text.md\nmodified:   text_3.md", 
            "title": "Stage the file and/or changes"
        }, 
        {
            "location": "/working-gitbash/#stage-all", 
            "text": "If you have many files to stage, use a shorthand command to stage all.  Run  git add .  or  git add --all  or  git add -A . Stage individual files with  git add  file .  git add --all\ngit status  The previously  unstaged  files are now  staged  and they appear in green.  To  unstage  the newly  staged  files, run  git reset  or  git reset HEAD  file  to unstage a specific file.  git reset HEAD text.md\ngit reset HEAD text_3.md", 
            "title": "Stage all"
        }, 
        {
            "location": "/working-gitbash/#stage-hunks", 
            "text": "You can stage a subset of the file by staging hunks. You can do this with the  git add -p  or  git add --patch  command. Git determines hunks by proximity/distance. Changes that are close together are  hunked  together.  First, run  git status  to see your  unstaged  files, then run  git add -p  file-name  to open the  diff  in Git Bash. Git will show you each hunk and ask you what to do in interactive shell mode.  If Git calculates multiple hunks, Git will show you one hunk at a time. After the hunk, Git gives the following options:     Option  What it does      y  Yes, stage this hunk.    n  No, don't stage this hunk.    q  Quit, clear this command.    a  Stage this and all hunks.    d  Don't stage this or any hunks.    /  Search for a hunk given a regex.    e  Edit the current hunk.    ?  Print help     Say that I only want to commit one hunk, not the other. I type  y  then hit  Enter  to stage the first hunk. Then I type  n , then hit  Enter  to not stage the second hunk. Now, when I run  git status , I see the same file in both  unstaged  (Changes to be committed) and  staged  (Changes not staged for commit) states. This represents the two hunks of the same file.  git status\nOn branch master\nYour branch is ahead of  origin/master  by  1  commit.\n   ( use  git push  to publish your  local  commits ) \n\nChanges to be committed:\n   ( use  git reset HEAD  file ...  to unstage ) \n\n        modified:   README.md\n\nChanges not staged  for  commit:\n   ( use  git add  file ...  to update what will be committed ) \n   ( use  git checkout --  file ...  to discard changes in working directory ) \n\n        modified:   README.md  The reason to do this might be to have a specific changeset associated with a single commit. This is useful when you want to reverse commit some changes or you want a more granular and focused commit history.", 
            "title": "Stage hunks"
        }, 
        {
            "location": "/working-gitbash/#split-hunks-with-patch", 
            "text": "If you have a file that you want to stage in hunks, but it only shows you one hunk, you can force a split.  After running  git add -p  file-name , print the patch help by entering  ?  option. Notice that you have more options than what's displayed.  s - split the current hunk into smaller hunk  Enter  s  and press enter. If git is able to automatically split the hunk, it will. If the hunk cannot be split, you'll have to do this manually with a GUI like Sourcetree (or read the git documentation to do this manually with Git Bash:  Git Tools - Interactive Staging ).  Info I am not documenting splitting hunks with Git Bash because it is much easier just to use Sourcetree.  See how you can do this with a GUI:  Stage the file and/or changes .", 
            "title": "Split hunks with patch"
        }, 
        {
            "location": "/working-gitbash/#commit-file-changes-to-a-branch", 
            "text": "Your files are staged, now you commit.  Run  git commit  to commit the changes.  git commit -m  some message   Use the  -m  flag to add a commit message. Messages should be succinct and useful. Include the JIRA if possible.  Run  git status .  If you've staged and committed all of the tracked files, you'll notice that when you run  git status  there is nothing to commit but that you are ahead of  origin/master .  git status\nOn branch master\nYour branch is ahead of  origin/master  by  1  commit.\n   ( use  git push  to publish your  local  commits ) \n\nnothing to commit, working tree clean  You need to push your changes to the remote. If your branch is tracked upstream, run  git push .  If you do not yet have an upstream branch, you'll have to set the upstream remote.  git push -u origin  branch-name   or  git push --set-upstream origin  branch-name   To learn about branching, and tracking branches upstream, see:  Branching with Git Bash .", 
            "title": "Commit file changes to a branch"
        }, 
        {
            "location": "/working-gitbash/#stash-file-changes-for-later", 
            "text": "You can stash changes to a file with the  git stash  command. Stash stores the changes to a file and the index, and returns to a clean working directory. This is helpful when you are making changes to a file that you do not yet want to commit to a branch, but that you don't want to lose.  There are a couple ways to do this. If we have a single file that has changes, we can stage and then stash.  git add  file \ngit stash save  A good stash message  \nThis creates a stash with the appended message and returns your index to a clean state.  Run  git status  to see that the  staged  file is no longer there.  Run  git stash list  to see your stash.  git stash list\nstash@ { 0 } : On master: a good stash message  You can create as many stashes as you want.  If I make another change to the file and stash it again, see what happens.  git stash list\nstash@ { 0 } : On master: another really good stash message\nstash@ { 1 } : On master: a good stash message  Notice that the first stash changed its index: stash@{1}. This is a zero-based index which means that 0 is the first item in the index.  To apply a stash, use  git stash apply  Now, we have two stashes in the index: 0 and 1.  git apply  by default applies the stash at the top of the index. When you apply a stash, it is brought back into the working directory in an  unstaged  state. You need to run  git add  to stage it and  git commit  to commit it.  git apply  does not delete the stash, so it remains in the index.  git stash pop  applies the top stash and deletes it.  You can select the stash to apply by specifying the index.  git stash apply stash@ { 1 }   This would apply the second stash, at index position 1.  To force delete a stash, use  git stash drop stash@{index} .  To delete all stashes, use  git stash clear .", 
            "title": "Stash file changes for later"
        }, 
        {
            "location": "/working-gitbash/#recommit-a-file-to-a-previous-version", 
            "text": "Sometimes you need to return a file to a previous version. You can do this with Git Bash by restoring a specific file to the state it was in for a given commit.  You need to take several steps:   Find the commit hash that you want to restore.  Check the file.  Checkout the file from that commit.  Commit the file again.", 
            "title": "Recommit a file to a previous version"
        }, 
        {
            "location": "/working-gitbash/#find-the-commit-hash", 
            "text": "You can see a quick commit history by running  git log . This command returns a list of commits and their SHA1s, dates, and commit messages. You might want to see a history for a specific file rather than the commit history of a branch. Run the following command to get a file history for a specific file.  git log -p --  file-name   You'll see a commit history with the file changes at each commit  If the file has been renamed, use the  --follow  flag to track a file across name changes.  git log --follow -p --  file-name   When you see the commit you want to recommit, copy the first 6 digits of the SHA1.", 
            "title": "Find the commit hash"
        }, 
        {
            "location": "/working-gitbash/#check-the-file", 
            "text": "To see all of the file changes at a commit, use  git diff .  git diff -p  hash  --  file-name   The  -p  flag prints the patches (the changes) for the file at the specific commit  hash>.\nYou'll see the patches for the named file for the specified commit.  You can see the state of the file (what the file looked like) at this commit wit  git show .  git show  hash : file-name   You'll see the state of the file at this commit. You won't see what patches are associated with the commit.", 
            "title": "Check the file"
        }, 
        {
            "location": "/working-gitbash/#checkout-and-recommit", 
            "text": "To restore the file to a previous version, run the following commands.  git checkout  hash  --  file-name \ngit add  file-name \ngit commit -m  restoring  file-name  to previous commit \ngit push  If you run  git log  again, your new commit will appear at the top.", 
            "title": "Checkout and recommit"
        }, 
        {
            "location": "/branches/", 
            "text": "Branches\n\n\nWhat is a branch\n\n\nHere is a really good article to read if you want to understand the underlying reference model of git:\n\nWhat is a branch\n.\n\n\nEssentially, a branch just points to a snapshot of our data (Flare documentation). So, when we create a branch, what are we doing?\n\n\nWhat is branching\n\n\nWhen you create a new branch, you are copying the state of another branch. Git does this by writing a new file that references the same SHA1 that it was copied from.\n\n\n\n\nWhen I create a branch called \ntesting\n from \nmaster\n, \ntesting\n and \nmaster\n are two branches that point to the exact same commit (since nothing has changed). This is how git gets away with not storing multiple copies of identical files (c.f. mapping different branches in TFS to your local machine).\n\n\nThe advantage of branches in git is that you can copy the state of data to an isolated working area. You can then make changes to the data without disrupting the original source. You can share this branch with others, and you can make as many commits to this branch as you want. Branching is cheap, and it's a practical way to collaborate on our documentation.\n\n\nWorking directory\n\n\nOne major difference between git and TFS is that git does not care about the files in your working directory. Git looks at the commit that your current branch points to and creates a working directory based on that commit.\n\n\nThe image below shows a personal git repo named \nexamples\n. The command shell to the right shows that I am currently on the \nmaster\n branch of this repo. My working directory currently has three files: a README file, and two text \nmd\n files (ignore the .git folder).\n\n\n\n\nA while ago, I created another branch (a copy of master) and I started doing work on this branch. Importantly, and a major difference from TFS, I don't need to open a new directory. My current working directory always reflects the branch that I am on and the files reflect the state of the branch.\n\n\nI run \ngit branch\n to see my branches.\n\n\ngit branch\n* master\n  example-branch\n\n\n\n\nI run \ngit checkout example-branch\n to switch to the other branch.\n\n\n$ git checkout example-branch\nSwitched to branch \nexample-branch\n\nYour branch is up to date with \norigin/example-branch\n.\n\n\n\n\nWhen I switch branches, Git rebuilds the working directory based on this branch. Now my working directory has the same README file and a different \nmd\n file. This means that my current branch does not have all of the files (and changes to files) that are on \nmaster\n, and vice versa.\n\n\n\n\nStorage\n\n\nGit doesn't store multiple copies of identical files. For example, the \nexamples\n repo has 4 files: README, text, text_1, and text_2. And, your machine has the same 4 files. When you switch branches, git looks at the commit that the branch points to and builds a working directory based on that information. The versioned files are stored as blobs in the \n.git\n folder, but we don't want to do any work in there.", 
            "title": "About Branches"
        }, 
        {
            "location": "/branches/#branches", 
            "text": "", 
            "title": "Branches"
        }, 
        {
            "location": "/branches/#what-is-a-branch", 
            "text": "Here is a really good article to read if you want to understand the underlying reference model of git: What is a branch .  Essentially, a branch just points to a snapshot of our data (Flare documentation). So, when we create a branch, what are we doing?", 
            "title": "What is a branch"
        }, 
        {
            "location": "/branches/#what-is-branching", 
            "text": "When you create a new branch, you are copying the state of another branch. Git does this by writing a new file that references the same SHA1 that it was copied from.   When I create a branch called  testing  from  master ,  testing  and  master  are two branches that point to the exact same commit (since nothing has changed). This is how git gets away with not storing multiple copies of identical files (c.f. mapping different branches in TFS to your local machine).  The advantage of branches in git is that you can copy the state of data to an isolated working area. You can then make changes to the data without disrupting the original source. You can share this branch with others, and you can make as many commits to this branch as you want. Branching is cheap, and it's a practical way to collaborate on our documentation.", 
            "title": "What is branching"
        }, 
        {
            "location": "/branches/#working-directory", 
            "text": "One major difference between git and TFS is that git does not care about the files in your working directory. Git looks at the commit that your current branch points to and creates a working directory based on that commit.  The image below shows a personal git repo named  examples . The command shell to the right shows that I am currently on the  master  branch of this repo. My working directory currently has three files: a README file, and two text  md  files (ignore the .git folder).   A while ago, I created another branch (a copy of master) and I started doing work on this branch. Importantly, and a major difference from TFS, I don't need to open a new directory. My current working directory always reflects the branch that I am on and the files reflect the state of the branch.  I run  git branch  to see my branches.  git branch\n* master\n  example-branch  I run  git checkout example-branch  to switch to the other branch.  $ git checkout example-branch\nSwitched to branch  example-branch \nYour branch is up to date with  origin/example-branch .  When I switch branches, Git rebuilds the working directory based on this branch. Now my working directory has the same README file and a different  md  file. This means that my current branch does not have all of the files (and changes to files) that are on  master , and vice versa.", 
            "title": "Working directory"
        }, 
        {
            "location": "/branches/#storage", 
            "text": "Git doesn't store multiple copies of identical files. For example, the  examples  repo has 4 files: README, text, text_1, and text_2. And, your machine has the same 4 files. When you switch branches, git looks at the commit that the branch points to and builds a working directory based on that information. The versioned files are stored as blobs in the  .git  folder, but we don't want to do any work in there.", 
            "title": "Storage"
        }, 
        {
            "location": "/branching_gitExt/", 
            "text": "Create a Branch with Git Extension\n\n\nLet's create a new branch!\n\n\nThere are several ways to create a new branch. Choose whichever is most convenient for you.\n\n\n\n\n\n\nBy right-clicking a commit on which to create a new branch.\n\n\n\n\n\n\nSelect the commit (usually the latest commit on the checked out branch)\n\n\n\n\n\n\nSelect \nCreate new branch\n.\n\n\n\n\n\n\nName your branch \nfeature/HLP-XXX\n or \nfeature/PS-XXX1\n where XXX is the correct JIRA number.\n\n\n\n\n\n\nSelect the \nCheckout after create\n box.\n\n\n\n\n\n\nSelect \nCreate branch\n.\n\n\n\n\n\n\n\n\n\n\nBy selecting \nCheckout new branch\n from the branch drop-down menu.\n\n\n\n\n\n\nSelect \nCheckout branch\n.\n\n\n\n\n\n\n\n\nName your branch \nfeature/HLP-XXX\n or \nfeature/PS-XXX1\n where XXX is the correct JIRA number.\n\n\n\n\n\n\nSelect \nCheckout\n.\n\n\n\n\n\n\n\n\n\n\nKeep track of branches\n\n\nThe benefit of a GUI like Git Extension is that we can visually keep track of branches, commits, and merges. We also have a clear view of the messages attached to commits. So let's look at the Git Extension UI in more detail as we work with branches.\n\n\nCheckout the topic on the \nGit Extension Graph\n.", 
            "title": "Create a Branch with Git Extension"
        }, 
        {
            "location": "/branching_gitExt/#create-a-branch-with-git-extension", 
            "text": "Let's create a new branch!  There are several ways to create a new branch. Choose whichever is most convenient for you.    By right-clicking a commit on which to create a new branch.    Select the commit (usually the latest commit on the checked out branch)    Select  Create new branch .    Name your branch  feature/HLP-XXX  or  feature/PS-XXX1  where XXX is the correct JIRA number.    Select the  Checkout after create  box.    Select  Create branch .      By selecting  Checkout new branch  from the branch drop-down menu.    Select  Checkout branch .     Name your branch  feature/HLP-XXX  or  feature/PS-XXX1  where XXX is the correct JIRA number.    Select  Checkout .", 
            "title": "Create a Branch with Git Extension"
        }, 
        {
            "location": "/branching_gitExt/#keep-track-of-branches", 
            "text": "The benefit of a GUI like Git Extension is that we can visually keep track of branches, commits, and merges. We also have a clear view of the messages attached to commits. So let's look at the Git Extension UI in more detail as we work with branches.  Checkout the topic on the  Git Extension Graph .", 
            "title": "Keep track of branches"
        }, 
        {
            "location": "/branch-gitbash/", 
            "text": "Create a Branch with Git Bash\n\n\nFollow along as I create a branch in the writing-resources repo.\n\n\nFirst, notice that I am currently in the git repo for this documentation project, and that I am on the \nmaster\n branch.\n\n\nBDM@usott-bdm MINGW64 /c/git/writing-resources \n(\nmaster\n)\n\n$\n\n\n\n\nNext, I'll create a branch called \ndevelop\n.\n\n\ngit branch develop\n\n\n\n\nThis command creates a new branch \ndevelop\n based on \nmaster\n (because I am on master).\n\n\nI can list my branches with \ngit branch\n.\n\n\ngit branch\ndevelop\n*master\n\n\n\n\nThe (*) indicates that I am on master, but there are two branches.\n\n\nTo switch branches, I use \ngit checkout\n.\n\n\ngit checkout develop\n\n\n\n\nThis command switches your current branch.\n\n\nI can combine the two previous commands into one, so I create and checkout at the same time:\n\n\ngit checkout -b \nbranch-name\n\n\n\n\n\nMy new branch is only on my machine. It won't appear on GitHub unless I push it to the remote (GitHub). For development branches this is required. For personal work, it is optional. If my work is only for me and I don't need to share it with anyone until it is finished, then I can leave it as a local branch.\n\n\nHowever, I want this branched to be tracked so others can help me on this document. I need to push my branch upstream and set it to track changes.\n\n\ngit push --set-upstream origin develop\n\n\n\n\nThe shorthand for this is:\n\n\ngit push -u origin \nbranch-name\n\n\n\n\n\nNow I have a new branch that is both on my machine and on GitHub.", 
            "title": "Create a Branch with Git Bash"
        }, 
        {
            "location": "/branch-gitbash/#create-a-branch-with-git-bash", 
            "text": "Follow along as I create a branch in the writing-resources repo.  First, notice that I am currently in the git repo for this documentation project, and that I am on the  master  branch.  BDM@usott-bdm MINGW64 /c/git/writing-resources  ( master ) \n$  Next, I'll create a branch called  develop .  git branch develop  This command creates a new branch  develop  based on  master  (because I am on master).  I can list my branches with  git branch .  git branch\ndevelop\n*master  The (*) indicates that I am on master, but there are two branches.  To switch branches, I use  git checkout .  git checkout develop  This command switches your current branch.  I can combine the two previous commands into one, so I create and checkout at the same time:  git checkout -b  branch-name   My new branch is only on my machine. It won't appear on GitHub unless I push it to the remote (GitHub). For development branches this is required. For personal work, it is optional. If my work is only for me and I don't need to share it with anyone until it is finished, then I can leave it as a local branch.  However, I want this branched to be tracked so others can help me on this document. I need to push my branch upstream and set it to track changes.  git push --set-upstream origin develop  The shorthand for this is:  git push -u origin  branch-name   Now I have a new branch that is both on my machine and on GitHub.", 
            "title": "Create a Branch with Git Bash"
        }, 
        {
            "location": "/branch-graph-gitExt/", 
            "text": "The Git Extension Graph\n\n\nWhen you open Git Extension, it looks something like this:\n\n\n\n\nWhen you first clone our documentation project (or any git repo), the first thing you'll notice a graph. This graph shows your commit history. Branches are indicated with labels that point to a commit. Each dot along the line is a previous commit with a commit message.\n\n\nYou can locate branches:\n\n\n\n\n\n\nIn the graph as labels beside commits.\n\n\n\n\n\n\nIn the branches drop-down menu in the second task bar.\n\n\n\n\n\n\nYou can toggle which branches show up in the graph under \nView\n.\n\n\nChecking commits\n\n\nThe commit history is important because it shows you what file(s) changed and what changed in the document.\n\n\nYou can click on a commit to bring up the commit details. There are 4 tabs:\n\n\n\n\n\n\n\n\nTab\n\n\nWhat you'll find under this tab\n\n\n\n\n\n\n\n\n\n\nCommit\n\n\nInfo about the commit, author, dates, SHA1, etc.\n\n\n\n\n\n\nFile tree\n\n\nA navigable file tree of the current repo.\n\n\n\n\n\n\nDiff\n\n\nThe differences added to the selected file in this commit.\n\n\n\n\n\n\nConsole\n\n\nA console to use command line.\n\n\n\n\n\n\n\n\n\n\nCommitting your work\n\n\nWhen you work on a file locally, git detects that the files in your working directory have changed, and it tracks those changes.\n\n\nInfo\nGit detects file changes when you click \nsave\n, for example, in Flare or in your text editor.\nIn the second menu bar, you will see an \nCommit\n button, sometimes it has a number beside it in parentheses. This number means that git has detected some file changes that you have not yet committed to the branch.\n\n\nWhen you work on files, they are added the working area and are currently unstaged. Before you add them to the repository, you need add them to the index by staging them.\n\n\nIn Git Extension, this looks like this:\n\n\n\n\nFiles in the red area are modified and in the working area. Files in the green area are modified and added to the index.\n\n\nThe actions that you'll need to do from this screen:\n\n\n\n\n\n\nStage a file using the down arrow.\n\n\n\n\n\n\nUnstage a file using the up arrow.\n\n\n\n\n\n\nAdd a commit message in the message area.\n\n\n\n\n\n\nCommit the files in the index to the repository.\n\n\n\n\n\n\nCommit and push files to the local and remote repositories.\n\n\n\n\n\n\nAfter you commit files to the repository, you can close this dialog. You'll see a new commit at the top of the graph with your commit message.\n\n\nCommitting locally but not pushing to remote\n\n\nFrom the main window, you can toggle your remote branches under \nView\n. In the screen capture below, I have toggled them ON (in red) so that they appear in the graph.\n\n\n\n\nNotice that they are pointing to previous commits, and importantly, different commits than their local counterparts. This means that my local \nmaster\n and \ndaily\n are out-of-sync with the remotes.\n\n\nTo push changes:\n\n\n\n\n\n\nUse the blue arrow to push changes to the remotes.\n\n\n\n\n\n\n\n\nThe default behaviour is to push the checked-out branch. You can also select the \nPush multiple branches\n tab to select more than one branch.\n\n\n\n\n\n\n\n\nNote that:\n\n\n\n\n\n\nOnly push shared branches.\n\n\n\n\n\n\nAll remotes are selected by default.\n\n\n\n\n\n\nForce rewind is the inverse of fast-forward merge, but it happens on the remote rather   than the local branch.\n\n\n\n\n\n\nChanges upstream\n\n\nWhat happens when someone else is working on the same branch as you, and they push their changes to \norigin/master\n while you have local changes committed but not pushed?\n\n\nWhen the remote and local branches diverge, the remote takes precedence in that we can't push changes to a remote if the history of the two branches is different. Git forces you to either \nfetch\n or \npull\n the changes from the remote before you \npush\n.\n\n\nIf you try to push first, Git Extension will throw this error.\n\n\n\n\nYou just need to do a \npull\n first. Select \nPull with last action\n.\n\n\nGit Extension will now do a \ngit pull\n followed by \ngit push\n. You will see the pull commit and the push commit on your graph.\n\n\n\n\nTip\n\n\nYou should get in the habit of running \ngit pull\n often and especially before you push to the remote.", 
            "title": "Git Extension Graph"
        }, 
        {
            "location": "/branch-graph-gitExt/#the-git-extension-graph", 
            "text": "When you open Git Extension, it looks something like this:   When you first clone our documentation project (or any git repo), the first thing you'll notice a graph. This graph shows your commit history. Branches are indicated with labels that point to a commit. Each dot along the line is a previous commit with a commit message.  You can locate branches:    In the graph as labels beside commits.    In the branches drop-down menu in the second task bar.    You can toggle which branches show up in the graph under  View .", 
            "title": "The Git Extension Graph"
        }, 
        {
            "location": "/branch-graph-gitExt/#checking-commits", 
            "text": "The commit history is important because it shows you what file(s) changed and what changed in the document.  You can click on a commit to bring up the commit details. There are 4 tabs:     Tab  What you'll find under this tab      Commit  Info about the commit, author, dates, SHA1, etc.    File tree  A navigable file tree of the current repo.    Diff  The differences added to the selected file in this commit.    Console  A console to use command line.", 
            "title": "Checking commits"
        }, 
        {
            "location": "/branch-graph-gitExt/#committing-your-work", 
            "text": "When you work on a file locally, git detects that the files in your working directory have changed, and it tracks those changes.  Info Git detects file changes when you click  save , for example, in Flare or in your text editor. In the second menu bar, you will see an  Commit  button, sometimes it has a number beside it in parentheses. This number means that git has detected some file changes that you have not yet committed to the branch.  When you work on files, they are added the working area and are currently unstaged. Before you add them to the repository, you need add them to the index by staging them.  In Git Extension, this looks like this:   Files in the red area are modified and in the working area. Files in the green area are modified and added to the index.  The actions that you'll need to do from this screen:    Stage a file using the down arrow.    Unstage a file using the up arrow.    Add a commit message in the message area.    Commit the files in the index to the repository.    Commit and push files to the local and remote repositories.    After you commit files to the repository, you can close this dialog. You'll see a new commit at the top of the graph with your commit message.", 
            "title": "Committing your work"
        }, 
        {
            "location": "/branch-graph-gitExt/#committing-locally-but-not-pushing-to-remote", 
            "text": "From the main window, you can toggle your remote branches under  View . In the screen capture below, I have toggled them ON (in red) so that they appear in the graph.   Notice that they are pointing to previous commits, and importantly, different commits than their local counterparts. This means that my local  master  and  daily  are out-of-sync with the remotes.  To push changes:    Use the blue arrow to push changes to the remotes.     The default behaviour is to push the checked-out branch. You can also select the  Push multiple branches  tab to select more than one branch.     Note that:    Only push shared branches.    All remotes are selected by default.    Force rewind is the inverse of fast-forward merge, but it happens on the remote rather   than the local branch.", 
            "title": "Committing locally but not pushing to remote"
        }, 
        {
            "location": "/branch-graph-gitExt/#changes-upstream", 
            "text": "What happens when someone else is working on the same branch as you, and they push their changes to  origin/master  while you have local changes committed but not pushed?  When the remote and local branches diverge, the remote takes precedence in that we can't push changes to a remote if the history of the two branches is different. Git forces you to either  fetch  or  pull  the changes from the remote before you  push .  If you try to push first, Git Extension will throw this error.   You just need to do a  pull  first. Select  Pull with last action .  Git Extension will now do a  git pull  followed by  git push . You will see the pull commit and the push commit on your graph.   Tip  You should get in the habit of running  git pull  often and especially before you push to the remote.", 
            "title": "Changes upstream"
        }, 
        {
            "location": "/best-practice-branch/", 
            "text": "Branching Best Practices\n\n\nTo avoid conflicts with local and remote branches, and to keep things consistent, here are some best practices.\n\n\n\n\n\n\nFetch/pull often and anytime.\n\n\n\n\n\n\nAlways \npull\n before you create a branch.\n\n\nThis ensures that your branch has all local and remote changes before you branch.\n1. Name feature branches:\n\n\nfeature/hlp-1\n\n\nfeature/ps-250\n\n\n\n\n\n\nAfter you merge a branch, delete the branch.\n\n\n\n\n\n\nName release branches:\n\n\nrelease/sense-jun-2018\n\n\nrelease/nprinting-sep-2020\n\n\n\n\n\n\nNEVER\n delete shared branches.\n\n\nmaster\n\n\ndaily\n\n\nrelease/x", 
            "title": "Branching Best Practices"
        }, 
        {
            "location": "/best-practice-branch/#branching-best-practices", 
            "text": "To avoid conflicts with local and remote branches, and to keep things consistent, here are some best practices.    Fetch/pull often and anytime.    Always  pull  before you create a branch.  This ensures that your branch has all local and remote changes before you branch.\n1. Name feature branches:  feature/hlp-1  feature/ps-250    After you merge a branch, delete the branch.    Name release branches:  release/sense-jun-2018  release/nprinting-sep-2020    NEVER  delete shared branches.  master  daily  release/x", 
            "title": "Branching Best Practices"
        }, 
        {
            "location": "/merge-gitExt/", 
            "text": "Merge with Git Extension\n\n\nAfter you have finished with a feature or a task, you'll want to merge your feature branch into daily so you can build the output. You need to do a  \ngit merge\n.\n\n\nSay we have the following structure, \nfeature/HLP-1\n and \ndaily\n.\n\n\n     A--B--C feature/HLP-1\n    /\nD--E--F--G daily\n\n\n\n\nLet's assume we are on \ndaily\n.\n\n\n\n\n\n\nfeature/HLP-1\n points to commit C, which has a history of B, A, and E.\n\n\nE is the commit where \nfeature/HLP-1\n diverged.\n\n\n\n\n\n\ndaily\n points to commit G, which has a history of F through D.\n\n\n\n\n\n\nOur goal is to merge \nfeature/HLP-1\n into \ndaily\n, resulting in:\n\n\n     A--B--C feature/HLP-1\n    /       \\\nD--E--F--G---H daily\n\n\n\n\ndaily\n now points to a new commit H that has both commit H and commit C as its parents.\n\n\nMerge\n\n\nI'll use my omni sandbox repo to show a merge with Git Extension.\n\n\nI created a \nfeature/hlp-1\n and did some work on this branch. I also did some work on \ndaily\n. \ndaily\n points to the commit with the message \"second commit\" and \nfeature/HLP-1\n points to a commit with the message \"Added condition\" Both branches have commits that the other branch does not have.\n\n\n\n\nSourcetree also shows me that I am on \nfeature/HLP-1\n (square commit).\n\n\nI want to take the latest commit from \nfeature/HLP-1\n and merge that into \ndaily\n.\n\n\n\n\n\n\nCheckout \ndaily\n.\n\n\n\n\n\n\nRihgt-click the latest commit on \nfeature/HLP-1\n.\n\n\n\n\n\n\nSelect \nmerge into current branch\n \n \nfeature/HLP-1\n\n\nA dialog opens that looks like this:\n\n\n\n\nThis dialog shows you the graphical representation of what will happen to your branches after a merge commit. Also, since the \nKeep single branch line if possible\n is selected, when you hover over the image you'll see this:\n\n\n\n\nThis is shwoing you a fast-forward merge if this is possible. In our current example, this is not possible since our branch histories differ.\n\n\n\n\n\n\nSelect \nMerge\n.\n\n\nThe graph now looks like this:\n\n\n\n\n\n\n\n\nDelete after finished\n\n\nMake sure you are not checkout on the branch that you want to delete.\n\n\n\n\n\n\nRight-click the commit beside the branch label in the graph.\n\n\n\n\n\n\nSelect \nDelete branch\n \n \nfeature/HLP-1\n\n\nA dialog opens. You can select \nForce delete\n if you have some uncommited changes on this branch that have not been merged (and that you don't want to keep).\n\n\n\n\n\n\nClick \nDelete\n.\n\n\n\n\n\n\nNote\nYou only want to delete feature branches after the work is finished that the commits have been squashed and cherry-picked to master.", 
            "title": "Merge with Git Extension"
        }, 
        {
            "location": "/merge-gitExt/#merge-with-git-extension", 
            "text": "After you have finished with a feature or a task, you'll want to merge your feature branch into daily so you can build the output. You need to do a   git merge .  Say we have the following structure,  feature/HLP-1  and  daily .       A--B--C feature/HLP-1\n    /\nD--E--F--G daily  Let's assume we are on  daily .    feature/HLP-1  points to commit C, which has a history of B, A, and E.  E is the commit where  feature/HLP-1  diverged.    daily  points to commit G, which has a history of F through D.    Our goal is to merge  feature/HLP-1  into  daily , resulting in:       A--B--C feature/HLP-1\n    /       \\\nD--E--F--G---H daily  daily  now points to a new commit H that has both commit H and commit C as its parents.", 
            "title": "Merge with Git Extension"
        }, 
        {
            "location": "/merge-gitExt/#merge", 
            "text": "I'll use my omni sandbox repo to show a merge with Git Extension.  I created a  feature/hlp-1  and did some work on this branch. I also did some work on  daily .  daily  points to the commit with the message \"second commit\" and  feature/HLP-1  points to a commit with the message \"Added condition\" Both branches have commits that the other branch does not have.   Sourcetree also shows me that I am on  feature/HLP-1  (square commit).  I want to take the latest commit from  feature/HLP-1  and merge that into  daily .    Checkout  daily .    Rihgt-click the latest commit on  feature/HLP-1 .    Select  merge into current branch     feature/HLP-1  A dialog opens that looks like this:   This dialog shows you the graphical representation of what will happen to your branches after a merge commit. Also, since the  Keep single branch line if possible  is selected, when you hover over the image you'll see this:   This is shwoing you a fast-forward merge if this is possible. In our current example, this is not possible since our branch histories differ.    Select  Merge .  The graph now looks like this:", 
            "title": "Merge"
        }, 
        {
            "location": "/merge-gitExt/#delete-after-finished", 
            "text": "Make sure you are not checkout on the branch that you want to delete.    Right-click the commit beside the branch label in the graph.    Select  Delete branch     feature/HLP-1  A dialog opens. You can select  Force delete  if you have some uncommited changes on this branch that have not been merged (and that you don't want to keep).    Click  Delete .    Note You only want to delete feature branches after the work is finished that the commits have been squashed and cherry-picked to master.", 
            "title": "Delete after finished"
        }, 
        {
            "location": "/merge-gitbash/", 
            "text": "Merge with Git Bash\n\n\nAfter you have finished with a feature or a task, you may want to merge your feature branch into another branch.\n\n\ngit merge\n is one of the processes that git uses when you run \ngit pull\n to retrieve commits from the remote (the other is \ngit fetch\n). When we want to merge different branches however, we must do this manually.\n\n\nSay we have the following structure, \nbranch-X\n and \nmaster\n.\n\n\n     A--B--C branch-X\n    /\nD--E--F--G master\n\n\n\n\nLet's assume we are on \nmaster\n.\n\n\n\n\n\n\nbranch-X\n points to commit C, which has a history of B, A, and E.\nE is the commit where \nbranch-X\n diverged.\n\n\n\n\n\n\nmaster\n points to commit H, which has a history of G through D.\n\n\n\n\n\n\nOur goal is to merge \nbranch-X\n into \nmaster\n, resulting in:\n\n\n     A--B--C branch-X\n    /       \\\nD--E--F--G---H master\n\n\n\n\nmaster\n now points to a new commit H that has both commit H and commit C as its parents.\n\n\nMerge\n\n\nI'll use my \nexamples\n repo again to show a merge with Git Bash.\n\n\nI created a \nbranch-X\n and did some work on this branch, and let's assume there are some other commits on \nmaster\n that are not on \nbranch-x\n. When I run \ngit branch\n I can see my branches and which branch I have checked out.\n\n\nBDM@usott-bdm MINGW64 /c/git/examples \n(\nmaster\n)\n\n$ git branch\n  branch-x\n* master\n\n\nI am currently on the \nmaster\n branch and my git looks something like this (from above):\n\n\n     A--B--C branch-X\n    /\nD--E--F--G master\n\n\n\n\nTo merge branches, run the following commands:\n\n\ngit merge branch-x -m \nmerge branch-x\n\n\n\n\n\nThe -m flag and message are important for Git Bash. A merge is a commit. You can run a merge command without a message, but Git will open the vim editor which is quite annoying. It's also a good habit to just leave messages about what you are doing.\n\n\nCheck your status:\n\n\ngit status\n$ git status\nOn branch master\nYour branch is ahead of \norigin/master\n by \n2\n commits.\n  \n(\nuse \ngit push\n to publish your \nlocal\n commits\n)\n\n\nnothing to commit, working tree clean\n\n\n\n\nAfter a merge, you'll get a status message that your branch is X commits behind \norigin/master\n. This just means you haven't pushed your merge commit to the remote.\n\n\nPush to remote:\n\n\ngit push\ngit status\nYour branch is up to date with \norigin/master\n.\n\nnothing to commit, working tree clean\n\n\n\n\nNext time you run git status you'll see a message that your up-to-date. \n\n\nWe still have the 2 branches, and we no longer need \nbranch-x\n.\n\n\nDelete\n\n\nMake sure you are not checkout on the branch that you want to delete.\n\n\nBDM@usott-bdm MINGW64 /c/git/examples \n(\nmaster\n)\n\n$ git branch\n  branch-x\n* master\n\n\n\n\nWe need to delete the branch both locally and remotely.\n\n\nRemotely\n\n\nWe delete the local branch and then push that change to origin.\n\n\ngit push origin -d branch-x\nTo https://github.com/kyleweishaar/examples.git\n - \n[\ndeleted\n]\n         branch-x\n\n\n\n\norigin\n is most often the name of the remote unless you manually changed the name in GitHub or specified another name when you pushed your branch to the remote.\n\n\nYou will get a confirmation string that the branch is deleted.\n\n\nLocally\n\n\nAfter we delete the branch remotely, check your branches again. The syntax to delete the branch locally is more obvious. After you delete your local branch, check branches again.\n\n\ngit branch\n  branch-x\n* master\ngit branch -d branch-x\nDeleted branch branch-x \n(\nwas 2855c94\n)\n.\ngit branch\n* master", 
            "title": "Merge with Git Bash"
        }, 
        {
            "location": "/merge-gitbash/#merge-with-git-bash", 
            "text": "After you have finished with a feature or a task, you may want to merge your feature branch into another branch.  git merge  is one of the processes that git uses when you run  git pull  to retrieve commits from the remote (the other is  git fetch ). When we want to merge different branches however, we must do this manually.  Say we have the following structure,  branch-X  and  master .       A--B--C branch-X\n    /\nD--E--F--G master  Let's assume we are on  master .    branch-X  points to commit C, which has a history of B, A, and E. E is the commit where  branch-X  diverged.    master  points to commit H, which has a history of G through D.    Our goal is to merge  branch-X  into  master , resulting in:       A--B--C branch-X\n    /       \\\nD--E--F--G---H master  master  now points to a new commit H that has both commit H and commit C as its parents.", 
            "title": "Merge with Git Bash"
        }, 
        {
            "location": "/merge-gitbash/#merge", 
            "text": "I'll use my  examples  repo again to show a merge with Git Bash.  I created a  branch-X  and did some work on this branch, and let's assume there are some other commits on  master  that are not on  branch-x . When I run  git branch  I can see my branches and which branch I have checked out.  BDM@usott-bdm MINGW64 /c/git/examples  ( master ) \n$ git branch\n  branch-x\n* master \nI am currently on the  master  branch and my git looks something like this (from above):       A--B--C branch-X\n    /\nD--E--F--G master  To merge branches, run the following commands:  git merge branch-x -m  merge branch-x   The -m flag and message are important for Git Bash. A merge is a commit. You can run a merge command without a message, but Git will open the vim editor which is quite annoying. It's also a good habit to just leave messages about what you are doing.  Check your status:  git status\n$ git status\nOn branch master\nYour branch is ahead of  origin/master  by  2  commits.\n   ( use  git push  to publish your  local  commits ) \n\nnothing to commit, working tree clean  After a merge, you'll get a status message that your branch is X commits behind  origin/master . This just means you haven't pushed your merge commit to the remote.  Push to remote:  git push\ngit status\nYour branch is up to date with  origin/master .\n\nnothing to commit, working tree clean  Next time you run git status you'll see a message that your up-to-date.   We still have the 2 branches, and we no longer need  branch-x .", 
            "title": "Merge"
        }, 
        {
            "location": "/merge-gitbash/#delete", 
            "text": "Make sure you are not checkout on the branch that you want to delete.  BDM@usott-bdm MINGW64 /c/git/examples  ( master ) \n$ git branch\n  branch-x\n* master  We need to delete the branch both locally and remotely.", 
            "title": "Delete"
        }, 
        {
            "location": "/merge-gitbash/#remotely", 
            "text": "We delete the local branch and then push that change to origin.  git push origin -d branch-x\nTo https://github.com/kyleweishaar/examples.git\n -  [ deleted ]          branch-x  origin  is most often the name of the remote unless you manually changed the name in GitHub or specified another name when you pushed your branch to the remote.  You will get a confirmation string that the branch is deleted.", 
            "title": "Remotely"
        }, 
        {
            "location": "/merge-gitbash/#locally", 
            "text": "After we delete the branch remotely, check your branches again. The syntax to delete the branch locally is more obvious. After you delete your local branch, check branches again.  git branch\n  branch-x\n* master\ngit branch -d branch-x\nDeleted branch branch-x  ( was 2855c94 ) .\ngit branch\n* master", 
            "title": "Locally"
        }, 
        {
            "location": "/build/", 
            "text": "How to run a build job\n\n\n\n\nWarning\n\n\nThese steps are temporary\n\n\n\n\nTo start a build:\n\n\n\n\n\n\nGo \nhere\n\n\n\n\n\n\nClick \n--- DOC - Start Build - LD\n\n\n\n\n\n\nSelect \nBuild with Parameters\n.\n\n\n\n\n\n\nSelect the product, the section, and the branch.\n\n\n\n\nNote\n\n\nThe daily branch is what you normally want to build to check daily work.\n\n\n\n\n\n\n\n\nTEMP REQ:\n\n\nDeselect \nABORT_BUILD_ON_LOG_PARSE_FAILURE\n.\n\n\n\n\nNote\n\n\nThe problem here - for you - is that this Start job kicks off another job where the log file is kind of messy. I'm (Ingemar) working on a tool to make it much easier to see the build result.\n\n\n\n\n\n\n\n\nTo check build log\n\n\n\n\n\n\nRun the build and remember the \nbuild number\n of your job.\n\n\n\n\n\n\nTo see the console output for you build job, click the red/green ball to the left of the build number.\n\n\n\n\n\n\nIn the console output, locate the link that says \nDOC-Build_help-site #XX completed\n where XX is your build number.\n\n\n\n\n\n\nClick the link.\n\n\n\n\n\n\nIn the left hand menu, click \nParsed Console Output\n. (If there are two entries, just choose one).\n\n\n\n\n\n\nIn the \nParsed Console Output\n, click \nError (X)\n. \n\n\nInside square brackets, you'll see the name of the build step where the problem occurs.\n\n\n\n\n\n\nOutput\n\n\n\n\n\n\nNPrinting: http://rd-docloc.rdlund.qliktech.com/LD/en-US/nprinting/\n\n\n\n\n\n\nSense: http://rd-docloc.rdlund.qliktech.com/LD/en-US/sense/\n\n\n\n\n\n\nQlikView: http://rd-docloc.rdlund.qliktech.com/LD/en-US/qlikview/\n\n\n\n\n\n\nConnectors: http://rd-docloc.rdlund.qliktech.com/LD/en-US/connectors/", 
            "title": "Run a build in Jenkins"
        }, 
        {
            "location": "/build/#how-to-run-a-build-job", 
            "text": "Warning  These steps are temporary", 
            "title": "How to run a build job"
        }, 
        {
            "location": "/build/#to-start-a-build", 
            "text": "Go  here    Click  --- DOC - Start Build - LD    Select  Build with Parameters .    Select the product, the section, and the branch.   Note  The daily branch is what you normally want to build to check daily work.     TEMP REQ:  Deselect  ABORT_BUILD_ON_LOG_PARSE_FAILURE .   Note  The problem here - for you - is that this Start job kicks off another job where the log file is kind of messy. I'm (Ingemar) working on a tool to make it much easier to see the build result.", 
            "title": "To start a build:"
        }, 
        {
            "location": "/build/#to-check-build-log", 
            "text": "Run the build and remember the  build number  of your job.    To see the console output for you build job, click the red/green ball to the left of the build number.    In the console output, locate the link that says  DOC-Build_help-site #XX completed  where XX is your build number.    Click the link.    In the left hand menu, click  Parsed Console Output . (If there are two entries, just choose one).    In the  Parsed Console Output , click  Error (X) .   Inside square brackets, you'll see the name of the build step where the problem occurs.", 
            "title": "To check build log"
        }, 
        {
            "location": "/build/#output", 
            "text": "NPrinting: http://rd-docloc.rdlund.qliktech.com/LD/en-US/nprinting/    Sense: http://rd-docloc.rdlund.qliktech.com/LD/en-US/sense/    QlikView: http://rd-docloc.rdlund.qliktech.com/LD/en-US/qlikview/    Connectors: http://rd-docloc.rdlund.qliktech.com/LD/en-US/connectors/", 
            "title": "Output"
        }, 
        {
            "location": "/cherrypick-gitExt/", 
            "text": "Cherry Pick with Git Extension\n\n\nCherry pick lets you select a commit from one branch and commit it to another.\n\n\nYou might want to do this when you want to incorporate some small changes but not all of the changes of a branch.\n\n\nCherry pick\n\n\nI want to cherry pick one commit from \nfeature/hlp-1\n and commit it to \nmaster\n. Let's say that I want the first commit with the message \"Fixed typos\".\n\n\n\n\n\n\n\n\nCheckout the branch you want to commit to (\nmaster\n)\n\n\n\n\n\n\nRight-click the commit that you want to cherry pick.\n\n\nA dialog opens.\n\n\n\n\nLeave both check boxes selected.\n\n\n\n\n\n\nClick \nCherry pick\n.\n\n\nThe graph should now look like this:\n\n\n\n\n\n\n\n\nResult\n\n\nThe commit that we cherry picked is now on the \nmaster\n branch, and it appears at the top of the graph.\n\n\nNotice that this does not result in a merge. The commit is just added to the tip of the branch as if the work was actually done on the \nmaster\n branch.", 
            "title": "Cherry Pick with Git Extension"
        }, 
        {
            "location": "/cherrypick-gitExt/#cherry-pick-with-git-extension", 
            "text": "Cherry pick lets you select a commit from one branch and commit it to another.  You might want to do this when you want to incorporate some small changes but not all of the changes of a branch.", 
            "title": "Cherry Pick with Git Extension"
        }, 
        {
            "location": "/cherrypick-gitExt/#cherry-pick", 
            "text": "I want to cherry pick one commit from  feature/hlp-1  and commit it to  master . Let's say that I want the first commit with the message \"Fixed typos\".     Checkout the branch you want to commit to ( master )    Right-click the commit that you want to cherry pick.  A dialog opens.   Leave both check boxes selected.    Click  Cherry pick .  The graph should now look like this:", 
            "title": "Cherry pick"
        }, 
        {
            "location": "/cherrypick-gitExt/#result", 
            "text": "The commit that we cherry picked is now on the  master  branch, and it appears at the top of the graph.  Notice that this does not result in a merge. The commit is just added to the tip of the branch as if the work was actually done on the  master  branch.", 
            "title": "Result"
        }, 
        {
            "location": "/blame-gitExt/", 
            "text": "Blame with Git Extension\n\n\nGit Blame is a command that shows what revision and author last modified each line of a file.\n\n\nFor this example, I'll use the current \nomni-project\n.\n\n\nGit Blame\n\n\nIn most cases, you want to know who was the person who made a specific change. Git blame lets you look at a file associated with a commit, and to see the last author to change each line in that file.\n\n\nFrom the main window graph:\n\n\n\n\n\n\nSelect a commit.\n\n\n\n\n\n\nSelect the \nFile tree\n tab.\n\n\n\n\n\n\nRight-click the file you want to blame.\n\n\n\n\n\n\nSelect \nBlame\n.\n\n\nA dialog opens.\n\n\n\n\nI selected the \n.gitignore\n file, which is file that git uses to filter certain files and file types.\n\n\nThis window contains a lot of information:\n\n\n\n\n\n\nGreen: The current commit, the author of the commit, the date of the commit, and SHA1.\n\n\n\n\n\n\nBlue: What the file looks like at this commit.\n\n\n\n\n\n\nRed: The change to the file made by the current author, at this commit.\n\n\n\n\n\n\nYellow: The previous changes, line-by-line, by author and date.\n\n\n\n\n\n\n\n\n\n\nDrill-down\n\n\nLet's say I want to know more information about when Output/** was added to the file.\n\n\n\n\n\n\nDouble-click on the line 10.\n\n\nThe dialog will now show the commit associated with the change from line 10.", 
            "title": "Blame with Git Extension"
        }, 
        {
            "location": "/blame-gitExt/#blame-with-git-extension", 
            "text": "Git Blame is a command that shows what revision and author last modified each line of a file.  For this example, I'll use the current  omni-project .", 
            "title": "Blame with Git Extension"
        }, 
        {
            "location": "/blame-gitExt/#git-blame", 
            "text": "In most cases, you want to know who was the person who made a specific change. Git blame lets you look at a file associated with a commit, and to see the last author to change each line in that file.  From the main window graph:    Select a commit.    Select the  File tree  tab.    Right-click the file you want to blame.    Select  Blame .  A dialog opens.   I selected the  .gitignore  file, which is file that git uses to filter certain files and file types.  This window contains a lot of information:    Green: The current commit, the author of the commit, the date of the commit, and SHA1.    Blue: What the file looks like at this commit.    Red: The change to the file made by the current author, at this commit.    Yellow: The previous changes, line-by-line, by author and date.", 
            "title": "Git Blame"
        }, 
        {
            "location": "/blame-gitExt/#drill-down", 
            "text": "Let's say I want to know more information about when Output/** was added to the file.    Double-click on the line 10.  The dialog will now show the commit associated with the change from line 10.", 
            "title": "Drill-down"
        }, 
        {
            "location": "/rebase-sourcetree/", 
            "text": "Rebase with Sourcetree\n\n\nRebasing is similar to a merge in that you are taking commits from one branching and applying them to another branch. However, rebasing applies the commits from one branch to another branch in a linear order.\n\n\nExplanation\n\n\nHere we have two branches: \nmaster\n and \nrebase\n.\n\n\n    A--B--C (rebase)\n   /\n  D--E--F (master)\n\n\n\n\nWhen you merge \nrebase\n into \nmaster\n, commit G is the result of merge. Commit G has two parents, C and F. You can think of this as 'the state of \nmaster\n at commit G is the combination of commit C and commit F.\n\n\n    A--B--C (rebase)\n   /       \\\n  D--E--F---G (master)\n\n\n\n\nWhen you rebase, you are applying the commits from \nrebase\n to \nmaster\n in a linear order. Commit A is applied first, followed by B, then by C.\n\n\n             A--B--C (rebase)(master)\n            /\n  D--E--F---\n\n\n\n\nExample\n\n\nLet's say I have two branches. I want to rebase the \nrebase\n branch onto \npersonal\n -- I want to take the commits from \nrebase\n and place them in linear order on the \npersonal\n branch.\n\n\n\n\nrebase\n has two commits that are not on \npersonal\n.\n\n\n\n\n\n\nCheckout \npersonal\n.\n\n\nInfo\nI need checkout the branch I want to merge/rebase into.\n\n\n\n\nClick \nMerge\n from the ribbon.\n\n\n\n\nPick the last commit on \nrebase\n.\n\n\n\n\nSelect \nRebase instead of merge\n.\n\n\n\n\nWarning\nIf the changes from \nrebase\n are already pushed to the remote, then rebasing now will cause a merge conflict. You should only rebase locally, and only before you push changes to the remote. Else, you will end up with a merge conflict.\n\n\n\n\nAfter rebase, the graph now shows a linear commit history rather than a commit merge history.\n\n\nInfo\nc.f with the merge graph.\n\n\n\n\n\n\nRebase\n\n\nMerge\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nI can delete \nrebase\n if it is no longer needed. To bring master up-to-date, I can merge \npersonal\n into \nmaster\n. The result is a linear commit history on \nmaster\n.\n\n\nRebasing is a good for when you want to keep the commit history when merging.", 
            "title": "Rebase with Sourcetree"
        }, 
        {
            "location": "/rebase-sourcetree/#rebase-with-sourcetree", 
            "text": "Rebasing is similar to a merge in that you are taking commits from one branching and applying them to another branch. However, rebasing applies the commits from one branch to another branch in a linear order.", 
            "title": "Rebase with Sourcetree"
        }, 
        {
            "location": "/rebase-sourcetree/#explanation", 
            "text": "Here we have two branches:  master  and  rebase .      A--B--C (rebase)\n   /\n  D--E--F (master)  When you merge  rebase  into  master , commit G is the result of merge. Commit G has two parents, C and F. You can think of this as 'the state of  master  at commit G is the combination of commit C and commit F.      A--B--C (rebase)\n   /       \\\n  D--E--F---G (master)  When you rebase, you are applying the commits from  rebase  to  master  in a linear order. Commit A is applied first, followed by B, then by C.               A--B--C (rebase)(master)\n            /\n  D--E--F---", 
            "title": "Explanation"
        }, 
        {
            "location": "/rebase-sourcetree/#example", 
            "text": "Let's say I have two branches. I want to rebase the  rebase  branch onto  personal  -- I want to take the commits from  rebase  and place them in linear order on the  personal  branch.   rebase  has two commits that are not on  personal .    Checkout  personal .  Info I need checkout the branch I want to merge/rebase into.   Click  Merge  from the ribbon.   Pick the last commit on  rebase .   Select  Rebase instead of merge .   Warning If the changes from  rebase  are already pushed to the remote, then rebasing now will cause a merge conflict. You should only rebase locally, and only before you push changes to the remote. Else, you will end up with a merge conflict.   After rebase, the graph now shows a linear commit history rather than a commit merge history.  Info c.f with the merge graph.    Rebase  Merge           I can delete  rebase  if it is no longer needed. To bring master up-to-date, I can merge  personal  into  master . The result is a linear commit history on  master .  Rebasing is a good for when you want to keep the commit history when merging.", 
            "title": "Example"
        }, 
        {
            "location": "/ff-sourcetree/", 
            "text": "Fast Forward Merge with Sourcetree\n\n\nA fast forward merge is like a rebase, but it is specific to a scenario where there have been no commits to the original branch since the time you branched off of it.\n\n\n    B--C--D (ff-branch)\n   /\n  A (master)\n\n\n\n\nThere are three commits on \nff-branch\n, but there are no new commits on \nmaster\n since \nff-branch\n branched off. This is when a fast-forward merge happens.\n\n\nIn Sourcetree, the graph is a bit confusing because we expect a branch to \"branch\" off of a commit, but this is only the case when two branches diverge.\n\n\n\n\nmaster\n points to a commit, and \nff-branch\n points to a different commit. However, \nmaster\n does not have any commits that \nff-branch\n does not have.\n\n\nForce merge\n\n\nIn the above situation, when you merge \nff-branch\n into \nmaster\n, the \nmaster\n pointer just moves up the graph, leaving each commit in its linear order.\n\n\nWe can force a true merge, which creates a new commit that has two parents, by selecting the \nCreate new commit even in fast-forward\n is possible.\n\n\n\n\nThe resulting graph shows what happens.\n\n\n.\n\n\nThe latest commit has one parent commit from the \nff-branch\n and one from \nmaster\n.\n\n\nThis option is useful when you want to preserve the true history of branches, even when a fast-forward is possible.", 
            "title": "Fastforward Merge with Sourcetree"
        }, 
        {
            "location": "/ff-sourcetree/#fast-forward-merge-with-sourcetree", 
            "text": "A fast forward merge is like a rebase, but it is specific to a scenario where there have been no commits to the original branch since the time you branched off of it.      B--C--D (ff-branch)\n   /\n  A (master)  There are three commits on  ff-branch , but there are no new commits on  master  since  ff-branch  branched off. This is when a fast-forward merge happens.  In Sourcetree, the graph is a bit confusing because we expect a branch to \"branch\" off of a commit, but this is only the case when two branches diverge.   master  points to a commit, and  ff-branch  points to a different commit. However,  master  does not have any commits that  ff-branch  does not have.", 
            "title": "Fast Forward Merge with Sourcetree"
        }, 
        {
            "location": "/ff-sourcetree/#force-merge", 
            "text": "In the above situation, when you merge  ff-branch  into  master , the  master  pointer just moves up the graph, leaving each commit in its linear order.  We can force a true merge, which creates a new commit that has two parents, by selecting the  Create new commit even in fast-forward  is possible.   The resulting graph shows what happens.  .  The latest commit has one parent commit from the  ff-branch  and one from  master .  This option is useful when you want to preserve the true history of branches, even when a fast-forward is possible.", 
            "title": "Force merge"
        }, 
        {
            "location": "/amend-sourcetree/", 
            "text": "Amend Commits with Sourcetree\n\n\nSometimes we can be commit-happy. Perhaps we committed something too soon, or maybe we left a really bad commit message. Git is designed not to lose anything in its history, but we can rewrite some of it.\n\n\nAmend a commit\n\n\nSay, you made a commit yesterday, and you now realize that you have a couple other changes that should be part of this commit.\n\n\nExample\n\n\nI deleted all the old files and committed them to \nmaster\n, but I forgot to delete one other file and include that in the latest commit.\n\n\nTo fix this, I'll delete the forgotten file and stage it. My graph will lok this this:\n\n\n\n\nNow I'll commit the staged change, as normal, except this time I want to amend it to the latest commit.\n\n\n\n\nSelect yes when the pop-up asks for confirmation.\n\n\nTip\nWhen amending a commit, you should not select \nPush immediately to origin/master\n. If you do, you'll end up with a conflict with the remote.\nEdit a commit message\n\n\nYou committed, but your message is not very useful. You can edit the message with \nInteractive Rebase\n.\n\n\nExample\n\n\nIn the example above, my commit message was \"delete old files\". Perhaps I want to be more specific.\n\n\nTo edit a commit message, I need to open \nInteractive rebase\n by selecting the parent of the commit I want to edit.\n\n\nTip\nWhen referring to the graph, the latest commit is the child of the commit that precedes it.\n\n\nThe commit with the commit message \"filling in info\" is a child of \"Getting synced up\".\n\n\nDo the following to edit a commit message:\n\n\n\n\nRight-click on the parent commit.\n\n\n\n\nSelect \nRebase children of ...\n\n\nA dialog opens.\n\n\n\n\n\n\nSelect \nEdit Message\n.\n\n\n\n\nEnter a new commit message.\n\n\nSelect the box beside \nAmend commit\n.\n\n\nSelect \nOK\n.\n\n\n\n\nYour commit now has a new message.", 
            "title": "Amend Commits with Sourcetree"
        }, 
        {
            "location": "/amend-sourcetree/#amend-commits-with-sourcetree", 
            "text": "Sometimes we can be commit-happy. Perhaps we committed something too soon, or maybe we left a really bad commit message. Git is designed not to lose anything in its history, but we can rewrite some of it.", 
            "title": "Amend Commits with Sourcetree"
        }, 
        {
            "location": "/amend-sourcetree/#amend-a-commit", 
            "text": "Say, you made a commit yesterday, and you now realize that you have a couple other changes that should be part of this commit.", 
            "title": "Amend a commit"
        }, 
        {
            "location": "/amend-sourcetree/#example", 
            "text": "I deleted all the old files and committed them to  master , but I forgot to delete one other file and include that in the latest commit.  To fix this, I'll delete the forgotten file and stage it. My graph will lok this this:   Now I'll commit the staged change, as normal, except this time I want to amend it to the latest commit.   Select yes when the pop-up asks for confirmation.  Tip When amending a commit, you should not select  Push immediately to origin/master . If you do, you'll end up with a conflict with the remote.", 
            "title": "Example"
        }, 
        {
            "location": "/amend-sourcetree/#edit-a-commit-message", 
            "text": "You committed, but your message is not very useful. You can edit the message with  Interactive Rebase .", 
            "title": "Edit a commit message"
        }, 
        {
            "location": "/amend-sourcetree/#example_1", 
            "text": "In the example above, my commit message was \"delete old files\". Perhaps I want to be more specific.  To edit a commit message, I need to open  Interactive rebase  by selecting the parent of the commit I want to edit.  Tip When referring to the graph, the latest commit is the child of the commit that precedes it.  The commit with the commit message \"filling in info\" is a child of \"Getting synced up\".  Do the following to edit a commit message:   Right-click on the parent commit.   Select  Rebase children of ...  A dialog opens.    Select  Edit Message .   Enter a new commit message.  Select the box beside  Amend commit .  Select  OK .   Your commit now has a new message.", 
            "title": "Example"
        }, 
        {
            "location": "/squash-gitExt/", 
            "text": "Squash Commits with Git Extension\n\n\nSquashing commits does exactly what it says! It takes two or more commits and squashes them into a single commit.\n\n\nThis is useful when you want to push your changes to a public branch as a single commit that represents a work task or feature. Specifically, this is what we need to do when we finish a feature and merge that work with \nmaster\n.\n\n\nWhen you are working locally, and committing early and often, small frequent commits are helpful for you, but it is probably less helpful for the team. Squashing keeps a simple commit history.\n\n\nSquash your commits\n\n\nI created a \nfeature/2\n branch and I have made three commits on this branch. I have already merged my feature branch into \ndaily\n and checked the output. My feature is complete. Now I want to squash my feature branch.\n\n\nMy Git Extension graph looks like this right now:\n\n\n\n\nTo squash your commits if Git Extension, we use \ngit reset --soft\n.\n\n\n\n\n\n\nFirst, make sure you check out your feature branch.\n\n\n\n\n\n\nRight-click the parent commit of the commits that you want to squash. In most cases, this is the commit that your branch was created from.\n\n\nIn the image above, the commit I want to pick is the one \nbefore\n \"Commit 1\" (the parent of that commit).\n\n\n\n\n\n\nSelect \nReset current branch to here\n.\n\n\nA dialog opens.\n\n\nSelect \nSoft: leave working directory and index untouched\n.\n\n\n\n\n\n\n\n\nSelect OK.\n\n\nWhen you come back to your graph, it will look a bit messy, but that is because the action rest the files from the feature branch commits. Notice the commit menu has a number beside it now.\n\n\n\n\n\n\nClick on the commit menu.\n\n\n\n\n\n\nAdd a commit message and select commit. Make sure you are not pushing these changes.\n\n\nYour commit message should be \"Squashing feature HLP-X\"\n\n\n\n\n\n\nNow you will see a single commit on your feature branch at the top of the graph.\n\n\n\n\n\n\n\n\nNow this commit can be cherry-picked anywhere it needs to go.\n\n\nSee \nCherry-pick with Git Extension\n.", 
            "title": "Squash Commits with Git Extension"
        }, 
        {
            "location": "/squash-gitExt/#squash-commits-with-git-extension", 
            "text": "Squashing commits does exactly what it says! It takes two or more commits and squashes them into a single commit.  This is useful when you want to push your changes to a public branch as a single commit that represents a work task or feature. Specifically, this is what we need to do when we finish a feature and merge that work with  master .  When you are working locally, and committing early and often, small frequent commits are helpful for you, but it is probably less helpful for the team. Squashing keeps a simple commit history.", 
            "title": "Squash Commits with Git Extension"
        }, 
        {
            "location": "/squash-gitExt/#squash-your-commits", 
            "text": "I created a  feature/2  branch and I have made three commits on this branch. I have already merged my feature branch into  daily  and checked the output. My feature is complete. Now I want to squash my feature branch.  My Git Extension graph looks like this right now:   To squash your commits if Git Extension, we use  git reset --soft .    First, make sure you check out your feature branch.    Right-click the parent commit of the commits that you want to squash. In most cases, this is the commit that your branch was created from.  In the image above, the commit I want to pick is the one  before  \"Commit 1\" (the parent of that commit).    Select  Reset current branch to here .  A dialog opens.  Select  Soft: leave working directory and index untouched .     Select OK.  When you come back to your graph, it will look a bit messy, but that is because the action rest the files from the feature branch commits. Notice the commit menu has a number beside it now.    Click on the commit menu.    Add a commit message and select commit. Make sure you are not pushing these changes.  Your commit message should be \"Squashing feature HLP-X\"    Now you will see a single commit on your feature branch at the top of the graph.     Now this commit can be cherry-picked anywhere it needs to go.  See  Cherry-pick with Git Extension .", 
            "title": "Squash your commits"
        }, 
        {
            "location": "/squash_all/", 
            "text": "Squash and Merge with GitBash\n\n\nLet's learn how to squash merge!\n\n\nWhat to do\n\n\nFirst, assume you have two branches:\n\n\n\n\n\n\nwork-branch\n\n\n\n\n\n\nsquash-branch\n\n\n\n\n\n\nWe'll do work on \nwork-branch\n and then squash merge into \nsquash-branch\n.\n\n\nNote\nSquashing is only useful when you have many commits.\nA--B--C--D (work-branch)\n\n\n\n\nAbove, we have 4 commits on \nwork-branch\n. I want to squash them so that I have a single commit that represents all of that work. Then, I want to merge that commit with my \nsquash-branch\n.\n\n\ngit checkout squash-branch\ngit merge --squash work-branch\nUpdating 0d02a7f..57ba06a\nFast-forward\nSquash commit -- not updating HEAD\n New Text Document \n(\n2\n)\n.txt \n|\n \n0\n\n New Text Document \n(\n3\n)\n.txt \n|\n \n0\n\n New Text Document \n(\n4\n)\n.txt \n|\n \n0\n\n New Text Document.txt     \n|\n \n0\n\n \n4\n files changed, \n0\n insertions\n(\n+\n)\n, \n0\n deletions\n(\n-\n)\n\n create mode \n100644\n New Text Document \n(\n2\n)\n.txt\n create mode \n100644\n New Text Document \n(\n3\n)\n.txt\n create mode \n100644\n New Text Document \n(\n4\n)\n.txt\n create mode \n100644\n New Text Document.txt\n\n\n\n\nThis command told git to first, checkout the branch we want to merge into. Next, it says to squash \nwork-branch\n. Git will list the files from each commit and then stage those files again.\n\n\ngit status\nOn branch squash-branch\nChanges to be committed:\n  \n(\nuse \ngit reset HEAD \nfile\n...\n to unstage\n)\n\n\n        \nyour changes\n\n\n\n\n\nWe need to commit those files.\n\n\ngit commit \n#\n\n\n\n\n\nThis commits the files and opens up the vim editor. The vim editor lets you type into the bash shell and then save the message. Your shell will look something like the following:\n\n\nSquashed commit of the following:\n\ncommit ...\nauthor: ...\ndate: ...\n\n    \nmessage\n\n\ncommit ...\nauthor: ...\ndate: ...\n\n    \nmessage\n\n\n...\n\n\n\n\nPress \nInsert\n on your keyboard. The cursor appears, find it by using the up or down arrows. You want to leave a message above the first line.\n\n\nsome message should go here\n\nSquashed commit of the following:\n\ncommit ...\nauthor: ...\ndate: ...\n\n    \nmessage\n\n\ncommit ...\nauthor: ...\ndate: ...\n\n    \nmessage\n\n\n...\n\n\n\n\nTo save your message, press \nesc\n and then \n:x\n. You should be taken back to the shell. It should look like this, with your message at the top:\n\n\ngit commit \n#\n\n\n[\nsquash-merge 3bde628\n]\n Some message here: Squashed commit of the following:\n \n5\n files changed, \n0\n insertions\n(\n+\n)\n, \n0\n deletions\n(\n-\n)\n\n create mode \n100644\n New Text Document - Copy \n(\n2\n)\n.txt\n create mode \n100644\n New Text Document - Copy \n(\n3\n)\n.txt\n create mode \n100644\n New Text Document - Copy \n(\n4\n)\n.txt\n create mode \n100644\n New Text Document - Copy.txt\n create mode \n100644\n New Text Document.txt\n\n\n\n\nWhat happened\n\n\nGit took the commits on your branch and squashed them. Then, git placed that commit on the branch you had checked out. The result is not a true merge but more like a cherry-pick.\n\n\n(my-branch) B--C--D --\n becomes --\n E (all commits squashed)\n\n(squash-branch) A -- E (commit E gets placed onto squash branch)", 
            "title": "Squash and Merge with Git Bash"
        }, 
        {
            "location": "/squash_all/#squash-and-merge-with-gitbash", 
            "text": "Let's learn how to squash merge!", 
            "title": "Squash and Merge with GitBash"
        }, 
        {
            "location": "/squash_all/#what-to-do", 
            "text": "First, assume you have two branches:    work-branch    squash-branch    We'll do work on  work-branch  and then squash merge into  squash-branch .  Note Squashing is only useful when you have many commits. A--B--C--D (work-branch)  Above, we have 4 commits on  work-branch . I want to squash them so that I have a single commit that represents all of that work. Then, I want to merge that commit with my  squash-branch .  git checkout squash-branch\ngit merge --squash work-branch\nUpdating 0d02a7f..57ba06a\nFast-forward\nSquash commit -- not updating HEAD\n New Text Document  ( 2 ) .txt  |   0 \n New Text Document  ( 3 ) .txt  |   0 \n New Text Document  ( 4 ) .txt  |   0 \n New Text Document.txt      |   0 \n  4  files changed,  0  insertions ( + ) ,  0  deletions ( - ) \n create mode  100644  New Text Document  ( 2 ) .txt\n create mode  100644  New Text Document  ( 3 ) .txt\n create mode  100644  New Text Document  ( 4 ) .txt\n create mode  100644  New Text Document.txt  This command told git to first, checkout the branch we want to merge into. Next, it says to squash  work-branch . Git will list the files from each commit and then stage those files again.  git status\nOn branch squash-branch\nChanges to be committed:\n   ( use  git reset HEAD  file ...  to unstage ) \n\n         your changes   We need to commit those files.  git commit  #   This commits the files and opens up the vim editor. The vim editor lets you type into the bash shell and then save the message. Your shell will look something like the following:  Squashed commit of the following:\n\ncommit ...\nauthor: ...\ndate: ...\n\n     message \n\ncommit ...\nauthor: ...\ndate: ...\n\n     message \n\n...  Press  Insert  on your keyboard. The cursor appears, find it by using the up or down arrows. You want to leave a message above the first line.  some message should go here \nSquashed commit of the following:\n\ncommit ...\nauthor: ...\ndate: ...\n\n     message \n\ncommit ...\nauthor: ...\ndate: ...\n\n     message \n\n...  To save your message, press  esc  and then  :x . You should be taken back to the shell. It should look like this, with your message at the top:  git commit  #  [ squash-merge 3bde628 ]  Some message here: Squashed commit of the following:\n  5  files changed,  0  insertions ( + ) ,  0  deletions ( - ) \n create mode  100644  New Text Document - Copy  ( 2 ) .txt\n create mode  100644  New Text Document - Copy  ( 3 ) .txt\n create mode  100644  New Text Document - Copy  ( 4 ) .txt\n create mode  100644  New Text Document - Copy.txt\n create mode  100644  New Text Document.txt", 
            "title": "What to do"
        }, 
        {
            "location": "/squash_all/#what-happened", 
            "text": "Git took the commits on your branch and squashed them. Then, git placed that commit on the branch you had checked out. The result is not a true merge but more like a cherry-pick.  (my-branch) B--C--D --  becomes --  E (all commits squashed)\n\n(squash-branch) A -- E (commit E gets placed onto squash branch)", 
            "title": "What happened"
        }, 
        {
            "location": "/recover-branch/", 
            "text": "Recover a deleted branch\n\n\nIf you forget to cherry-pick your feature to \nmaster\n, and you delete your branch, then you'll need to locate the commits on the \ndaily\n branch.\n\n\nFilter\n\n\nThe easiest way to find your commits is to use the filter option in Git Extension.\n\n\n\n\n\n\n\n\nSelect \nAuthor\n.\n\n\n\n\n\n\nEnter your name exactly as it appears in the commit information (name + email).\n\n\nFirst Last \ntrigram@qlik.com\n\n\nFor example:\n\n\nAuthor\n:\n \nFirst\n \nLast\n \ntrigram\n@\nqlik\n.\ncom\n\n\nDate\n:\n \n19\n \nhours\n \nago\n \n(\n7\n/4/\n2018\n \n4\n:\n08\n:\n57\n \nPM\n)\n\n\nCommit\n \nhash\n:\n \n3\nd79a92d56a9742d7dcc2963c554000894e401d4\n\n\n\n\n\n\n\n\n\nAfter you add the filter, you only see your own commits.\n\n\n\n\nThe branch I want to recover is \nfeature/HLP-3103\n. I can see which files were changed in each commit by clicking on a commit and looking at the \nCommit\n (shows the files) and \nDiff\n (shows the changes) tabs.\n\n\nThe commits highlighted in red are the commits that I am interested in.\n\n\nCreate branch\n\n\nI want to create a branch at the latest relevant commit that was merged into \ndaily\n.\n\n\n\n\n\n\nRight-click the commit.\n\n\n\n\n\n\nSelect \nCreate new branch\n.\n\n\n\n\n\n\nName the branch with the correct feature name (example):\n\n\nfeature/HLP-3103\n\n\n\n\n\n\nSelect \nView\n \n \nShow current branch only\n.\n\n\n\n\n\n\n\n\nNote\nNow the graph is showing your recovered branch and only your commits.\n\n\nNote\n\n\nRemember that a branch is just a reference to a commit. Once I located the last merge commit into \ndaily\n, I can create a new branch based on that commit. Recovering a commit means adding a reference file to the HEAD of the deleted branch.\n\n\n\n\nReset files\n\n\n\n\n\n\nClear the author filter.\n\n\n\n\n\n\nFind the parent of the first commit you did on this feature branch.\n\n\nIn the image below, in red are the commits associated with the feature. In green is the parent of the earliest commit on my feature branch. How do I know it is the parent? Locate the earliest commit and trace that branch down.\n\n\n\n\n*   Replace hard-coded SW version with variable (earliest commit)\n|\n|\n*   Merge branch \nPortPS2226\n into daily (parent)\n\n\n\n\n\n\n\n\nRight-click the parent commit.\n\n\n\n\n\n\nSelect \nReset current branch to here\n.\n\n\n\n\n\n\nLeave the \nMixed\n option.\n\n\n\n\n\n\nThe commit button will indicate that you have some files to commit. Click on the commit button to open the dialog. You will see some files in the working area. You will have a clean index (because you selected the mixed reset).\n\n\nYou might see files not part of your feature. This is because other people have committed to \ndaily\n, and these commits are parents of other commits in the new branch.\n\n\n\n\n\n\n\n\nSelect the files associated with the feature and stage them.\n\n\nThey should be in the index.\n\n\n\n\n\n\nWrite a commit message: feature name.\n\n\n\n\n\n\nSelect \nCommit\n.\n\n\n\n\nAt the top of the branch we now have a single commit associated with the feature.\n\n\n\n\nTip\n\n\nYou still have to reset the files in the working area. Open the commit window and click\n\nRest all changes\n.\n\n\n\n\n\n\n\n\nCherry-pick to \nmaster\n\n\n\n\n\n\nSelect \nView\n \n \nShow all branches\n.\n\n\n\n\n\n\nCheckout \nmaster\n.\n\n\n\n\n\n\nPull \nmaster\n.\n\n\n\n\n\n\nRight-click the commit on your feature branch.\n\n\n\n\n\n\nSelect \nCherry-pick\n.\n\n\n\n\n\n\nResolve conflicts if there are any.\n\n\n\n\n\n\nThe result\n\n\n\n\nVerify the content before deleting the local branch.", 
            "title": "Recover a deleted branch"
        }, 
        {
            "location": "/recover-branch/#recover-a-deleted-branch", 
            "text": "If you forget to cherry-pick your feature to  master , and you delete your branch, then you'll need to locate the commits on the  daily  branch.", 
            "title": "Recover a deleted branch"
        }, 
        {
            "location": "/recover-branch/#filter", 
            "text": "The easiest way to find your commits is to use the filter option in Git Extension.     Select  Author .    Enter your name exactly as it appears in the commit information (name + email).  First Last  trigram@qlik.com  For example:  Author :   First   Last   trigram @ qlik . com  Date :   19   hours   ago   ( 7 /4/ 2018   4 : 08 : 57   PM )  Commit   hash :   3 d79a92d56a9742d7dcc2963c554000894e401d4     After you add the filter, you only see your own commits.   The branch I want to recover is  feature/HLP-3103 . I can see which files were changed in each commit by clicking on a commit and looking at the  Commit  (shows the files) and  Diff  (shows the changes) tabs.  The commits highlighted in red are the commits that I am interested in.", 
            "title": "Filter"
        }, 
        {
            "location": "/recover-branch/#create-branch", 
            "text": "I want to create a branch at the latest relevant commit that was merged into  daily .    Right-click the commit.    Select  Create new branch .    Name the branch with the correct feature name (example):  feature/HLP-3103    Select  View     Show current branch only .     Note Now the graph is showing your recovered branch and only your commits.  Note  Remember that a branch is just a reference to a commit. Once I located the last merge commit into  daily , I can create a new branch based on that commit. Recovering a commit means adding a reference file to the HEAD of the deleted branch.", 
            "title": "Create branch"
        }, 
        {
            "location": "/recover-branch/#reset-files", 
            "text": "Clear the author filter.    Find the parent of the first commit you did on this feature branch.  In the image below, in red are the commits associated with the feature. In green is the parent of the earliest commit on my feature branch. How do I know it is the parent? Locate the earliest commit and trace that branch down.   *   Replace hard-coded SW version with variable (earliest commit)\n|\n|\n*   Merge branch  PortPS2226  into daily (parent)    Right-click the parent commit.    Select  Reset current branch to here .    Leave the  Mixed  option.    The commit button will indicate that you have some files to commit. Click on the commit button to open the dialog. You will see some files in the working area. You will have a clean index (because you selected the mixed reset).  You might see files not part of your feature. This is because other people have committed to  daily , and these commits are parents of other commits in the new branch.     Select the files associated with the feature and stage them.  They should be in the index.    Write a commit message: feature name.    Select  Commit .   At the top of the branch we now have a single commit associated with the feature.   Tip  You still have to reset the files in the working area. Open the commit window and click Rest all changes .", 
            "title": "Reset files"
        }, 
        {
            "location": "/recover-branch/#cherry-pick-to-master", 
            "text": "Select  View     Show all branches .    Checkout  master .    Pull  master .    Right-click the commit on your feature branch.    Select  Cherry-pick .    Resolve conflicts if there are any.", 
            "title": "Cherry-pick to master"
        }, 
        {
            "location": "/recover-branch/#the-result", 
            "text": "Verify the content before deleting the local branch.", 
            "title": "The result"
        }, 
        {
            "location": "/revert-gitExt/", 
            "text": "Reverse a Commit with Git Extension\n\n\nMistakes happen, so it's good to know that we can reverse our commit in a safe way.\n\n\nReversing a commit is the preferred way to undo the changes associated with a commit because it does not delete the commit. Instead, it creates a new commit in which it reverses the changes that occurred in the commit,thus saving your commit history.\n\n\nDifference between Git Reset and Git Revert\n\n\nGit Revert\n\n\n\n\nSafe process\n\n\nKeeps commit history\n\n\nReverse the commit by creating a new commit\n\n\n\n\nA--B--C\ngit revert (reverse C by committing D)\nA--B--C--D\n\n\n\n\nGit Reset\n\n\n\n\nDestructive process\n\n\nCostly mistakes\n\n\nHistory is lost\n\n\n\n\nA--B--C\ngit reset (delete C)\nA--B\n\n\n\n\nExample\n\n\nTo reverse a commit, do the following:\n\n\n\n\nRight-click the commit that you want to revert.\n\n\nSelect \nRevert commit\n.\n\n\n\n\nClick \nRevert this commit\n.\n\n\nIf you leave the \nAutomatically create a new commit\n box unselected, the files associated with this commit will be staged but not commited. You will have to commit them manually. This might be useful if a commit contains many files, and you only want to revert \nsome\n of the files.\n\n\n\n\n\n\nFor example, after reverting a commit but not automatically merging, I can see 6 files in the index.\n\n\n\n\nI only want to revert changes associated with the Engine API.\n\n\n\n\n\n\nUnstage the files that you don't want to revert.\n\n\n\n\n\n\n\n\nAdd a commit message of add to the auto-generated message.\n\n\n\n\n\n\nSelect \nCommit\n.\n\n\nThe unstaged files are still modified in the working area.\n\n\n\n\n\n\n\n\nHighlight the unstaged files.\n\n\n\n\n\n\nRight-click the highlighted files.\n\n\n\n\n\n\nSelect \nReset file or directory changes\n.\n\n\n\n\n\n\nNow your working area is back to normal and you have reverted the selected files from the commit.", 
            "title": "Revert Commits with Git Extension"
        }, 
        {
            "location": "/revert-gitExt/#reverse-a-commit-with-git-extension", 
            "text": "Mistakes happen, so it's good to know that we can reverse our commit in a safe way.  Reversing a commit is the preferred way to undo the changes associated with a commit because it does not delete the commit. Instead, it creates a new commit in which it reverses the changes that occurred in the commit,thus saving your commit history.", 
            "title": "Reverse a Commit with Git Extension"
        }, 
        {
            "location": "/revert-gitExt/#difference-between-git-reset-and-git-revert", 
            "text": "", 
            "title": "Difference between Git Reset and Git Revert"
        }, 
        {
            "location": "/revert-gitExt/#git-revert", 
            "text": "Safe process  Keeps commit history  Reverse the commit by creating a new commit   A--B--C\ngit revert (reverse C by committing D)\nA--B--C--D", 
            "title": "Git Revert"
        }, 
        {
            "location": "/revert-gitExt/#git-reset", 
            "text": "Destructive process  Costly mistakes  History is lost   A--B--C\ngit reset (delete C)\nA--B", 
            "title": "Git Reset"
        }, 
        {
            "location": "/revert-gitExt/#example", 
            "text": "To reverse a commit, do the following:   Right-click the commit that you want to revert.  Select  Revert commit .   Click  Revert this commit .  If you leave the  Automatically create a new commit  box unselected, the files associated with this commit will be staged but not commited. You will have to commit them manually. This might be useful if a commit contains many files, and you only want to revert  some  of the files.    For example, after reverting a commit but not automatically merging, I can see 6 files in the index.   I only want to revert changes associated with the Engine API.    Unstage the files that you don't want to revert.     Add a commit message of add to the auto-generated message.    Select  Commit .  The unstaged files are still modified in the working area.     Highlight the unstaged files.    Right-click the highlighted files.    Select  Reset file or directory changes .    Now your working area is back to normal and you have reverted the selected files from the commit.", 
            "title": "Example"
        }, 
        {
            "location": "/delete-gitExt/", 
            "text": "Reset a Commit with Git Extension\n\n\nWarning\nGit Reset (delete) is a destructive process, and by this I mean that git reset changes the history of a branch and when you change histories you increase the chances of having problematic merges between branches. Only reset a commit if it is absolutely necessary.\nInstead, use \nGit Revert\n.\nThere may be times when you need to reset (delete) a commit, but this should be a last-resort operation. However, reset is also the function we use to squash commits, so some of this content might be familiar. This topic covers deleted commits rather than squashing them.\n\n\nThere are three options:\n\n\n\n\n\n\n\n\nReset\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSoft\n\n\nReverts branch to previous commit and keeps the file(s) in the index.\n\n\n\n\n\n\nMixed\n\n\nReverts branch to previous commit and unstages the file(s).\n\n\n\n\n\n\nHard\n\n\nReverts branch to previous commit and deletes any changes associated with the deleted commit.\n\n\n\n\n\n\n\n\n\n\nTip\n\n\nYou most always want to do a soft or mixed reset.\n\n\n\n\nTo reset commits, do the following:\n\n\n\n\n\n\nRight-click the parent of the commit you want to delete and select \nReset current branch to here\n.\n\n\nA dialog opens.\n\n\n\n\n\n\n\n\nSelect one of the options.\n\n\n\n\n\n\nClick \nOK\n.\n\n\n\n\n\n\nReset options\n\n\nIf you select \nSoft\n:\n\n\n\n\nFiles are re-\nstaged\n (they are kept in the index)\n\n\n\n\nIf you select \nMixed\n:\n\n\n\n\nFiles are \nunstaged\n(they are kept in the working area)\n\n\n\n\nIf you select \nHard\n:\n\n\n\n\nFiles and changes are deleted and no pending changes remain.(the commit and files are deleted)\n\n\n\n\nDifference between Git Reset and Git Revert\n\n\nGit Reset\n\n\n\n\nDestructive process\n\n\nCostly mistakes\n\n\nHistory is lost\n\n\n\n\nA--B--C\ngit reset (delete C)\nA--B\n\n\n\n\nGit Revert\n\n\n\n\nSafe process\n\n\nKeeps commit history\n\n\nReverse the commit by creating a new commit\n\n\n\n\nA--B--C\ngit revert (reverse C by committing D)\nA--B--C--D", 
            "title": "Reset Commits with Git Extension"
        }, 
        {
            "location": "/delete-gitExt/#reset-a-commit-with-git-extension", 
            "text": "Warning Git Reset (delete) is a destructive process, and by this I mean that git reset changes the history of a branch and when you change histories you increase the chances of having problematic merges between branches. Only reset a commit if it is absolutely necessary. Instead, use  Git Revert . There may be times when you need to reset (delete) a commit, but this should be a last-resort operation. However, reset is also the function we use to squash commits, so some of this content might be familiar. This topic covers deleted commits rather than squashing them.  There are three options:     Reset  Description      Soft  Reverts branch to previous commit and keeps the file(s) in the index.    Mixed  Reverts branch to previous commit and unstages the file(s).    Hard  Reverts branch to previous commit and deletes any changes associated with the deleted commit.      Tip  You most always want to do a soft or mixed reset.   To reset commits, do the following:    Right-click the parent of the commit you want to delete and select  Reset current branch to here .  A dialog opens.     Select one of the options.    Click  OK .", 
            "title": "Reset a Commit with Git Extension"
        }, 
        {
            "location": "/delete-gitExt/#reset-options", 
            "text": "If you select  Soft :   Files are re- staged  (they are kept in the index)   If you select  Mixed :   Files are  unstaged (they are kept in the working area)   If you select  Hard :   Files and changes are deleted and no pending changes remain.(the commit and files are deleted)", 
            "title": "Reset options"
        }, 
        {
            "location": "/delete-gitExt/#difference-between-git-reset-and-git-revert", 
            "text": "", 
            "title": "Difference between Git Reset and Git Revert"
        }, 
        {
            "location": "/delete-gitExt/#git-reset", 
            "text": "Destructive process  Costly mistakes  History is lost   A--B--C\ngit reset (delete C)\nA--B", 
            "title": "Git Reset"
        }, 
        {
            "location": "/delete-gitExt/#git-revert", 
            "text": "Safe process  Keeps commit history  Reverse the commit by creating a new commit   A--B--C\ngit revert (reverse C by committing D)\nA--B--C--D", 
            "title": "Git Revert"
        }, 
        {
            "location": "/recover/", 
            "text": "Recover a Deleted Commit\n\n\nWell, you've decided to delete a commit, but now you realize you shouldn't have done that! Not all is lost, but you'll need to abandon Sourcetree and open up Git Bash.\n\n\nTo recover a deleted commit (or any deleted object), do the following:\n\n\n\n\nOpen Git Bash\n\n\ncd\n into the local repository.\n\n\n\n\nRun \ngit fsck\n = file system consistency check.\n\n\nfsck --lost-found\n looks for objects that are not referenced by a branch.\n\n\n$ git fsck --lost-found\nChecking object directories: \n100\n% \n(\n256\n/256\n)\n, \ndone\n.\ndangling commit 3822a0f32d606bbd6c9f7967906d6ff7ff41ae94\ndangling commit 4cd6ae078fa0008f806b49414cb5b2a5a154d136\ndangling tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904\n...\n\n\nDangling objects are not associated with a branch. They exist in the git log but they are not traceable to anything (because you deleted it!).\n\n\nUnfortunately, there is no particular order to these dangling objects so it is difficult to know what we're looking for. If you can't find it with \ngit fsck\n, run \nreflog\n.\n\n\n\n\n\n\nRun \ngit reflog\n.\n\n\n$ git reflog\ne4ba017 \n(\nHEAD -\n master\n)\n HEAD@\n{\n0\n}\n: reset: moving to e4ba0172eb34744932e514717e8cb411a280a36f\nbcbb398 HEAD@\n{\n1\n}\n: commit: Going to delete this file, and \nthen\n I will recover it!\ne4ba017 \n(\nHEAD -\n master\n)\n HEAD@\n{\n2\n}\n: revert: Revert \nAdd a text file\n\nef5dd4d HEAD@\n{\n3\n}\n: commit: Add a text file\n...\n\n\n\n\nThe \nreflog\n keeps a record of when the tip of a branch was updated. Deleting a commit is also like updating the tip of a branch. The reflof is ordered.\n\n\nInfo\nRemember that a git reset takes the commit message from the commit you are reseting the branch to, and puts a \nreset:\n infront. Use this to located deleted commits.\nThe commit I wan to recover is bcbb398 (the commit above it was \nreset\n).\n\n\n\n\n\n\nType \nq\n to quit the interactive mode.\n\n\n\n\n\n\nRun \ngit show \nSHA1\n.\n\n\n$ git show bcbb398\ncommit bcbb398a9a2d391c01074dc27e306787c5b6ece9\nAuthor: kyleweishaar \nkyle.weishaar@qlik.com\n\nDate:   Thu Feb \n22\n \n11\n:04:12 \n2018\n -0500\n\nGoing to delete this file, and \nthen\n I will recover it!\n\ndiff --git a/New Text Document.txt b/New Text Document.txt\nnew file mode \n100644\n\nindex \n0000000\n..e69de29\n\n\n\n\nI can confirm that this is the commit that I want to recover.\n\n\nNow I want to merge this dangling commit back to my branch.\n\n\n\n\n\n\nMake sure I am on the branch I want to merge into.\n\n\nRun \ngit merge \nSHA1\n.\n\n\ngit merge bcbb398\n\n\n\n\n\n\n\n\nOpen Sourcetree.\n\n\nYou should see the recovered commit.\n\n\nTip\nYou might see some uncommitted changes that come along with the merge. These should not be a problem. Just have a look to see what is uncommitted before you commit them.", 
            "title": "Recover Deleted commits"
        }, 
        {
            "location": "/recover/#recover-a-deleted-commit", 
            "text": "Well, you've decided to delete a commit, but now you realize you shouldn't have done that! Not all is lost, but you'll need to abandon Sourcetree and open up Git Bash.  To recover a deleted commit (or any deleted object), do the following:   Open Git Bash  cd  into the local repository.   Run  git fsck  = file system consistency check.  fsck --lost-found  looks for objects that are not referenced by a branch.  $ git fsck --lost-found\nChecking object directories:  100 %  ( 256 /256 ) ,  done .\ndangling commit 3822a0f32d606bbd6c9f7967906d6ff7ff41ae94\ndangling commit 4cd6ae078fa0008f806b49414cb5b2a5a154d136\ndangling tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904\n... \nDangling objects are not associated with a branch. They exist in the git log but they are not traceable to anything (because you deleted it!).  Unfortunately, there is no particular order to these dangling objects so it is difficult to know what we're looking for. If you can't find it with  git fsck , run  reflog .    Run  git reflog .  $ git reflog\ne4ba017  ( HEAD -  master )  HEAD@ { 0 } : reset: moving to e4ba0172eb34744932e514717e8cb411a280a36f\nbcbb398 HEAD@ { 1 } : commit: Going to delete this file, and  then  I will recover it!\ne4ba017  ( HEAD -  master )  HEAD@ { 2 } : revert: Revert  Add a text file \nef5dd4d HEAD@ { 3 } : commit: Add a text file\n...  The  reflog  keeps a record of when the tip of a branch was updated. Deleting a commit is also like updating the tip of a branch. The reflof is ordered.  Info Remember that a git reset takes the commit message from the commit you are reseting the branch to, and puts a  reset:  infront. Use this to located deleted commits. The commit I wan to recover is bcbb398 (the commit above it was  reset ).    Type  q  to quit the interactive mode.    Run  git show  SHA1 .  $ git show bcbb398\ncommit bcbb398a9a2d391c01074dc27e306787c5b6ece9\nAuthor: kyleweishaar  kyle.weishaar@qlik.com \nDate:   Thu Feb  22   11 :04:12  2018  -0500\n\nGoing to delete this file, and  then  I will recover it!\n\ndiff --git a/New Text Document.txt b/New Text Document.txt\nnew file mode  100644 \nindex  0000000 ..e69de29  I can confirm that this is the commit that I want to recover.  Now I want to merge this dangling commit back to my branch.    Make sure I am on the branch I want to merge into.  Run  git merge  SHA1 .  git merge bcbb398    Open Sourcetree.  You should see the recovered commit.  Tip You might see some uncommitted changes that come along with the merge. These should not be a problem. Just have a look to see what is uncommitted before you commit them.", 
            "title": "Recover a Deleted Commit"
        }, 
        {
            "location": "/fix-workflow/", 
            "text": "Reversing Commits with Sourcetree\n\n\nThis example is taken from the \nomni-project\n trial.\n\n\nScenario\n\n\nWe had three commits that need to be reversed but not every single file change that was part of the commit should be reversed.\nEverything was committed to \nmaster\n.\n\n\nThe three commits happened one after the other: \"third wave\", \"second wave\", \"third wave\".\n\n\n\n\nEach commit contained a whole lot of changes. Most of the changes in these three commits were changes to links. It turns out that the changes we made won't work, but we want to keep the non-link changes.\n\n\nSolution\n\n\nInfo\nThere are probably many solutions.\nI create a branch called \nverify-fix\n that is just a copy of \nmaster\n. Then I \ngit reverse commit\n the three commits that I don't want. \nReverse commit\n is a safe operation because it create a new commit that does not include the changes from the commit that I want to exclude.\n\n\nYou can see above, the three commits on \nverify-fix\n has three reverse commits. Now, it does not have the same commit history as \nmaster\n.\n\n\nNow I want to re-add some of the files from those commits to my \nverify-fix\n branch.\n\n\nTo add file changes from the commits I reverted, do the following:\n\n\n\n\nSelect one of the commits.\n\n\nSelect the file/change that you want to stage.\n\n\nRight-click the file.\n\n\n\n\nSelect \nReset to Commit\n.\n\n\nTip\nThe icons beside each file show you want type of change it is.\n\n\n\n\nWhen finished, select the \nuncommitted changes\n, write a commit message and commit.\n\n\n\n\n\n\nResult\n\n\n\n\nI reversed the full commits I didn't want, and then I made a new commit and added the changed files from the reversed commits that I did want.\n\n\nMerge\n\n\n\n\nCheckout \nmaster\n.\n\n\nClick \nPull\n to make sure I have the latest \nmaster\n.\n\n\nClick \nMerge\n.\n\n\n\n\nSelect the commit I want to merge into \nmaster\n.\n\n\nThis is my latest commit on \nverify-fix\n.\n\n\n\n\n\n\nClick \nOK\n.\n\n\n\n\n\n\nResult\n\n\n\n\nSince there were no other changes to \nmaster\n, git did a \nfast-forward merge\n.\n\n\nThe last step is to push the changes to origin and to delete my branch if it is done.", 
            "title": "Reversing Commits with Sourcetree"
        }, 
        {
            "location": "/fix-workflow/#reversing-commits-with-sourcetree", 
            "text": "This example is taken from the  omni-project  trial.", 
            "title": "Reversing Commits with Sourcetree"
        }, 
        {
            "location": "/fix-workflow/#scenario", 
            "text": "We had three commits that need to be reversed but not every single file change that was part of the commit should be reversed.\nEverything was committed to  master .  The three commits happened one after the other: \"third wave\", \"second wave\", \"third wave\".   Each commit contained a whole lot of changes. Most of the changes in these three commits were changes to links. It turns out that the changes we made won't work, but we want to keep the non-link changes.", 
            "title": "Scenario"
        }, 
        {
            "location": "/fix-workflow/#solution", 
            "text": "Info There are probably many solutions. I create a branch called  verify-fix  that is just a copy of  master . Then I  git reverse commit  the three commits that I don't want.  Reverse commit  is a safe operation because it create a new commit that does not include the changes from the commit that I want to exclude.  You can see above, the three commits on  verify-fix  has three reverse commits. Now, it does not have the same commit history as  master .  Now I want to re-add some of the files from those commits to my  verify-fix  branch.  To add file changes from the commits I reverted, do the following:   Select one of the commits.  Select the file/change that you want to stage.  Right-click the file.   Select  Reset to Commit .  Tip The icons beside each file show you want type of change it is.   When finished, select the  uncommitted changes , write a commit message and commit.", 
            "title": "Solution"
        }, 
        {
            "location": "/fix-workflow/#result", 
            "text": "I reversed the full commits I didn't want, and then I made a new commit and added the changed files from the reversed commits that I did want.", 
            "title": "Result"
        }, 
        {
            "location": "/fix-workflow/#merge", 
            "text": "Checkout  master .  Click  Pull  to make sure I have the latest  master .  Click  Merge .   Select the commit I want to merge into  master .  This is my latest commit on  verify-fix .    Click  OK .", 
            "title": "Merge"
        }, 
        {
            "location": "/fix-workflow/#result_1", 
            "text": "Since there were no other changes to  master , git did a  fast-forward merge .  The last step is to push the changes to origin and to delete my branch if it is done.", 
            "title": "Result"
        }, 
        {
            "location": "/revert-merge-commit/", 
            "text": "Reverting an Old Merge Commit\n\n\nThis will probably only need to be done by the release engineer or build engineer.\n\n\nFind the merge commit\n\n\n\n\nCheckout the branch that has the merge commit that you want to revert.\n\n\nLocated the SHA1 of the merge commit that you want to revert.\n\n\n\n\nIn a shell:\n\n\ngit revert -m \n1\n \nSHA1\n\n\n\n\n\nThe interactive shell opens.\n\n\n\n\n\n\nEnter a revert merge commit message.\n\n\ni\n for insert.\n\n\nType the message.\n\n\nesc\n then \n:x\n to exit shell.\n\n\n\n\n\n\nFinish by pushing changes. \n\n\n\n\nVerify that the commit has been reversed.", 
            "title": "Revert merge commits"
        }, 
        {
            "location": "/revert-merge-commit/#reverting-an-old-merge-commit", 
            "text": "This will probably only need to be done by the release engineer or build engineer.", 
            "title": "Reverting an Old Merge Commit"
        }, 
        {
            "location": "/revert-merge-commit/#find-the-merge-commit", 
            "text": "Checkout the branch that has the merge commit that you want to revert.  Located the SHA1 of the merge commit that you want to revert.   In a shell:  git revert -m  1   SHA1   The interactive shell opens.    Enter a revert merge commit message.  i  for insert.  Type the message.  esc  then  :x  to exit shell.    Finish by pushing changes.    Verify that the commit has been reversed.", 
            "title": "Find the merge commit"
        }, 
        {
            "location": "/fetch-v-pull/", 
            "text": "Fetch vs. Pull\n\n\nWhen you run \ngit pull\n, git takes the changes from the remote that you don't have locally and tries to merge those changes to the local branch that you are working in. If you don\u2019t closely manage your branches, you may run into frequent conflicts.\n\n\nWhen you run \ngit fetch\n, git gathers any commits from the remote branch that do not exist in your current branch and stores them in your local repository. However, it does not merge them with your current branch. This is particularly useful if you need to keep your repository up to date, but are working on something that might break if you update your files. To integrate the commits into your master branch, you use \nmerge\n.\n\n\nVisual aids\n\n\n\n\nfetch\n is a simple process.\n\n\n\n\npull\n is a complex process (\nfetch\n + \nmerge\n).\n\n\n\n\n\n\n\n\nSourcetree\n\n\nLet's say there are changes on the remote \nmaster\n branch.\n\n\n\n\n\n\nClick \nFetch\n from the ribbon.\n\n\nNotice that the pull button is marked with a number. This indicates how many commits were fetched from the remote that are now in your local repository, but are not yet merged with your current branch.\n\n\n\n\n\n\n\n\nClick \nPull\n from the ribbon to merge the fetched changes.\n\n\nYou can continue to commit changes to your local branch. Now the push button is marked with a number that indicates how many commits from the local branch are not pushed to the remote.\n\n\n\n\nYou cannot push your changes to the remote before you pull.\n\n\n\n\n\n\nAfter you pull the changes, the graph will show a merge commit and an auto-generated message.\n\n\n\n\nGit Bash\n\n\nWith Git Bash, we rely less on visual cues and more on running the appropriate commands.\n\n\nLet's say there are changes on the remote \nmaster\n branch.\n\n\ngit status\nOn branch master\nYour branch is up to date with \norigin/master\n.\n\nnothing to commit, working tree clean\n\n\n\n\nI haven't fetched anything yet, so the local branch looks to be up-to-date with \nmaster\n.\n\n\ngit fetch\nremote: Counting objects: \n3\n, \ndone\n.\nremote: Compressing objects: \n100\n% \n(\n3\n/3\n)\n, \ndone\n.\nremote: Total \n3\n \n(\ndelta \n2\n)\n, reused \n0\n \n(\ndelta \n0\n)\n, pack-reused \n0\n\nUnpacking objects: \n100\n% \n(\n3\n/3\n)\n, \ndone\n.\nFrom https://github.com/qlik-trial/help-writing-resources\n   ff55aec..543a71c  master     -\n origin/master\n\n\n\n\nWhen I run \ngit fetch\n, I can see that some objects were fetched from the remote.\n\n\ngit status\nOn branch master\nYour branch is behind \norigin/master\n by \n1\n commit, and can be fast-forwarded.\n  \n(\nuse \ngit pull\n to update your \nlocal\n branch\n)\n\n\nnothing to commit, working tree clean\n\n\n\n\nNow when I run \ngit status\n, git tells me that I am behind by 1 commit. So, git fetch took the changes from the remote and placed them in my local repository, but it did not merge them with my local branch.\n\n\nI can continue to commit locally, using \ngit add\n and \ngit commit\n.\n\n\ngit status\nOn branch master\nYour branch and \norigin/master\n have diverged,\nand have \n1\n and \n1\n different commits each, respectively.\n  \n(\nuse \ngit pull\n to merge the remote branch into yours\n)\n\n\nnothing to commit, working tree clean\n\n\n\n\nGit is telling me that I have 1 commit to pull, and 1 commit to push (just like Sourcetree but without the visual cues).\n\n\nI need to pull before I push.\n\n\nRecommendation\nThe shell is telling you to run \ngit pull\n. Remember though, pull is two operations: \nfetch\n and \nmerge\n. Since you purposely used \ngit fetch\n, you should probably use \ngit merge\n. This will merge the commits from your fetch, but it wont pull any new changes from remote. For the sake of consistency, I'll use \ngit pull\n to finish the example.\nWhen I run \ngit pull\n, git puts me into interactive mode.\n\n\nRemember in the Sourcetree example above, Sourcetree creates an automatic commit message. Git Bash creates the message but does not save it.\n\n\nYour shell will look like this (the commit message is boxed in green):\n\n\n\n\nTo save this message\n\n\n\n\nEnter \nesc\n.\n\n\nThen, type \n:x\n to save and exit interactive mode.\n\n\n\n\nTo change this message\n\n\n\n\nEnter \ni\n (stands for insert).\n\n\nYour cursor will open beside the message. You can delete or add the message.\n\n\nThen type \nesc\n.\n\n\nThen, type \n:x\n to save and exit interactive mode.\n\n\n\n\nInfo\nIf you don't have any local commits when you run \ngit pull\n, you will not enter interactive mode since git is able to do a fast-forward merge.\n\ngit pull\nFast-forward\nmkdocs.yml \n|\n \n2\n +-\n\n1\n file changed, \n1\n insertion\n(\n+\n)\n, \n1\n deletion\n(\n-\n)\n\n\nKey take away\n\n\nUse \ngit fetch\n often to continuously update your local repository with changes from the remote. User \ngit merge\n to merge those changes.", 
            "title": "Fetch vs. Pull"
        }, 
        {
            "location": "/fetch-v-pull/#fetch-vs-pull", 
            "text": "When you run  git pull , git takes the changes from the remote that you don't have locally and tries to merge those changes to the local branch that you are working in. If you don\u2019t closely manage your branches, you may run into frequent conflicts.  When you run  git fetch , git gathers any commits from the remote branch that do not exist in your current branch and stores them in your local repository. However, it does not merge them with your current branch. This is particularly useful if you need to keep your repository up to date, but are working on something that might break if you update your files. To integrate the commits into your master branch, you use  merge .", 
            "title": "Fetch vs. Pull"
        }, 
        {
            "location": "/fetch-v-pull/#visual-aids", 
            "text": "fetch  is a simple process.   pull  is a complex process ( fetch  +  merge ).", 
            "title": "Visual aids"
        }, 
        {
            "location": "/fetch-v-pull/#sourcetree", 
            "text": "Let's say there are changes on the remote  master  branch.    Click  Fetch  from the ribbon.  Notice that the pull button is marked with a number. This indicates how many commits were fetched from the remote that are now in your local repository, but are not yet merged with your current branch.     Click  Pull  from the ribbon to merge the fetched changes.  You can continue to commit changes to your local branch. Now the push button is marked with a number that indicates how many commits from the local branch are not pushed to the remote.   You cannot push your changes to the remote before you pull.    After you pull the changes, the graph will show a merge commit and an auto-generated message.", 
            "title": "Sourcetree"
        }, 
        {
            "location": "/fetch-v-pull/#git-bash", 
            "text": "With Git Bash, we rely less on visual cues and more on running the appropriate commands.  Let's say there are changes on the remote  master  branch.  git status\nOn branch master\nYour branch is up to date with  origin/master .\n\nnothing to commit, working tree clean  I haven't fetched anything yet, so the local branch looks to be up-to-date with  master .  git fetch\nremote: Counting objects:  3 ,  done .\nremote: Compressing objects:  100 %  ( 3 /3 ) ,  done .\nremote: Total  3   ( delta  2 ) , reused  0   ( delta  0 ) , pack-reused  0 \nUnpacking objects:  100 %  ( 3 /3 ) ,  done .\nFrom https://github.com/qlik-trial/help-writing-resources\n   ff55aec..543a71c  master     -  origin/master  When I run  git fetch , I can see that some objects were fetched from the remote.  git status\nOn branch master\nYour branch is behind  origin/master  by  1  commit, and can be fast-forwarded.\n   ( use  git pull  to update your  local  branch ) \n\nnothing to commit, working tree clean  Now when I run  git status , git tells me that I am behind by 1 commit. So, git fetch took the changes from the remote and placed them in my local repository, but it did not merge them with my local branch.  I can continue to commit locally, using  git add  and  git commit .  git status\nOn branch master\nYour branch and  origin/master  have diverged,\nand have  1  and  1  different commits each, respectively.\n   ( use  git pull  to merge the remote branch into yours ) \n\nnothing to commit, working tree clean  Git is telling me that I have 1 commit to pull, and 1 commit to push (just like Sourcetree but without the visual cues).  I need to pull before I push.  Recommendation The shell is telling you to run  git pull . Remember though, pull is two operations:  fetch  and  merge . Since you purposely used  git fetch , you should probably use  git merge . This will merge the commits from your fetch, but it wont pull any new changes from remote. For the sake of consistency, I'll use  git pull  to finish the example. When I run  git pull , git puts me into interactive mode.  Remember in the Sourcetree example above, Sourcetree creates an automatic commit message. Git Bash creates the message but does not save it.  Your shell will look like this (the commit message is boxed in green):", 
            "title": "Git Bash"
        }, 
        {
            "location": "/fetch-v-pull/#to-save-this-message", 
            "text": "Enter  esc .  Then, type  :x  to save and exit interactive mode.", 
            "title": "To save this message"
        }, 
        {
            "location": "/fetch-v-pull/#to-change-this-message", 
            "text": "Enter  i  (stands for insert).  Your cursor will open beside the message. You can delete or add the message.  Then type  esc .  Then, type  :x  to save and exit interactive mode.   Info If you don't have any local commits when you run  git pull , you will not enter interactive mode since git is able to do a fast-forward merge. git pull\nFast-forward\nmkdocs.yml  |   2  +- 1  file changed,  1  insertion ( + ) ,  1  deletion ( - )", 
            "title": "To change this message"
        }, 
        {
            "location": "/fetch-v-pull/#key-take-away", 
            "text": "Use  git fetch  often to continuously update your local repository with changes from the remote. User  git merge  to merge those changes.", 
            "title": "Key take away"
        }, 
        {
            "location": "/conflicts/", 
            "text": "Conflicts\n\n\nMerge conflicts can happen when:\n\n\n\n\nYou merge changes where a document(s) are in conflict.\n\n\nEdit a file that as been deleted.\n\n\n\n\nSometimes, things can become messy when many people are working on the same stuff. Fixing conflicts is pretty easy though, especially with the right tools.\n\n\nOn a single branch, each subsequent commit replaces the previous.\n\n\nA---B---C---D ... (feature-a)\n\n\n\n\nWhen you merge, conflicts can happen.\n\n\nA---B---C---G (feature-a-albin)\n\\          /\n D---E----F (feature-a-tove)\n\n\n\n\nIf the same file has changed on both branches, which version, F or C, is correct when you merge to create G?\n\n\nConflicts with Sourcetree\n\n\nLet's say we have two writers, Albin and Tove, and they are working together on a new product scenario. They both edit the same file, and there is a conflict when one of them merges the two branches.\n\n\n\n\n\n\n\n\nTove change\n\n\nAlbin Change\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLet's say that Tove wants to merge Albin's branch with hers. When Tove clicks \nMerge\n, she sees a merge conflict error. There are several ways to solve the conflict.\n\n\nSimple resolution using Mine vs. Theirs\n\n\nClick the file and look at the File diff window.\n\n\n\n\nThe conflict is highlighted by angle brackets (\n,\n) and the the two conflicts are separated by equal signs (=).\n\n\nTove can choose which change to keep using the \nmine\n or \ntheirs\n method.\n\n\n\n\nRight-click the staged file.\n\n\n\n\nSelect \nResolve Conflicts\n.\n    A dialog opens.\n\n\n\n\n\n\n\n\nSelect \nResolve Using 'Mine'\n to keep the current branch version.\n\n\n(or) Select \nResolve Using 'Theirs'\n to keep the other version.\n\n\nLet's keep Albin's version for this example.\n\n\n\n\n\n\n\n\nTip\n\n\nIf you can't remember which resolution method to use, don't worry! When you select either option, a dialog opens before resolving the conflict asking you if you want to keep the file from commit number X.\n\n\n\n\n\n\nYou can verify the commit you want to keep by using the hash. We can see Albin's version is from commit \nbd4f62d\n.\n\n\n\n\n\n\n\n\nSelect \nOK\n.\n\n\nYou'll see a merge commit in the Sourcetree graph that is uncommited.\n\n\n\n\n\n\nSelect \nCommit\n from the ribbon.\n\n\n\n\n\n\nEnter a merge commit message.\n\n\nThere will be some auto-generated message about the conflict resolution.\n\n\n\n\n\n\nThe conflict is resolved. You can now safely delete unused branches.\n\n\nUsing an external merge tool\n\n\nSolving a conflict might not always be as easy as picking mine or theirs. Sometimes you'll need to customize the merge. This is also easy with a simple text editor.\n\n\nLet's go through a complex and likely scenario.\n\n\n\n\nBoth Albin and Tove are working on a DataMarket feature.\n\n\nThey both create a feature branch.\n\n\nThey both change the same file.\n\n\nThey update the TOC.\n\n\nThey update the target.\n\n\n\n\nWhen they merge, they will have several conflicts, possibly in \nhtm\n files, and in \nfltoc\n and \nfltar\n files.\n\n\nLet's look at where our writers are at.\n\n\n\n\nEach writer branch has its own commit history.\n\n\nLet's say that Tove is responsible for delivering this feature, so she merges Albin's branch with hers. The TOC does not produce a conflict even though they both changed it. This is because each other's changes do not conflict with the other.\n\n\nWhen Tove clicks on the conflict target file, she sees exactly what is conflicting.\n\n\nFixing the target conflict\n\n\n\n\nThe change in the green box is not in conflict (there are no conflict characters \n,\n,=).\n\n\nThe first red box shows that the stylesheet was changed on both branches. The second red box shows a new line \nUseDeviceWidth =\"true\"\n.\n\n\nInfo\nYou can't solve this merge conflict in Flare and you might see an error message in Flare when you get a merge conflict. You can just close it.\nSince target files are mostly just config settings or text fields, using a \nmine\n or \ntheirs\n strategy will work for solving these types of errors, since you'll never want to combine changes. But, to make this example more complicated than it needs to be, I'll choose one of changes from each branch which will force me to use an external tool.\n\n\n\n\nI want to use the common_print.css stylesheet\n\n\nI want to use the device width setting.\n\n\n\n\nThe best option is to open the file in a text editor and make the change manually.\n\n\nTove opens the file in VS Code.\n\n\n\n\nWith VS Code, Tove selects which changes to keep and then saves the file. She goes back to Sourcetree. The target conflicts are gone.\n\n\nFixing the htm conflict\n\n\nTove will fix the htm file in the exact same way. She opens the file in VS Code. She select which changes to keep. She saves the file, and then she goes back to Sourcetree.\n\n\nFinishing the commit\n\n\nTove still has the same files in both \nstaged\n and \nunstaged\n areas. She needs to clean up before the commit.\n\n\n\n\n\n\nSelect \nStage All\n.\n\n\nThe \nunstaged\n files will disappear.\n\n\n\n\n\n\nSelect \nCommit\n from the ribbon.\n\n\n\n\n\n\nTove will build locally and verify the changes before deleting unused branches.\n\n\nFringe case: deleted files\n\n\nTove deleted a file called New Text Document. Albin didn't know and was editing this document on his branch. When Tove merged Albin's branch, there was a merge conflict for the deleted file.\n\n\nSourcetree will not show a conflict in file diff area because a diff requires two files. Currently there is only a file on \nalbin-branch\n. Tove cannot resolve using a \nmine\n-\ntheirs\n strategy because the file does not exist. If she selects \nmine\n (meaning hers), Sourcetree throws an error.\n\n\nAssuming there are other changes on Albin's branch that Tove wants to keep, she will right-click the deleted file and select \nRemove\n. This should remove it from all file areas in Sourcetree.\n\n\nTove can now commit the remaing changes and merge.\n\n\nConflicts with Git Bash\n\n\nRecommendation\nRead the Sourcetree example which goes into more detail about the conflicts. The GUI will help you visuzalize what is happening with a conflict.\nLet's say I \ngit push\n and I get an error like the following:\n\n\ngit push\nTo https://github.com/qlik-trial/omni-project.git\n ! \n[\nrejected\n]\n          new-branch -\n new-branch \n(\nfetch first\n)\n\nerror: failed to push some refs to \nhttps://github.com/qlik-trial/omni-project.git\n\nhint: Updates were rejected because the remote contains work that you \ndo\n\nhint: not have locally. This is usually caused by another repository pushing\nhint: to the same ref. You may want to first integrate the remote changes\nhint: \n(\ne.g., \ngit pull ...\n)\n before pushing again.\nhint: See the \nNote about fast-forwards\n in \ngit push --help\n \nfor\n details.\n\n\n\n\nGit is saying that I can't \npush\n because the remote copy of the branch has diverged -- it has content that I don't have on my local branch. It is also telling me that I need to \nfetch\n first. So let's do that.\n\n\nWhat we want to do is:\n\n\n\n\nFetch the changes from remote.\n\n\nMerge those changes with local.\n\n\nPush our changes to remote.\n\n\n\n\ngit fetch\ngit merge\ngit push\n\n\n\n\nIf the changes that someone else pushed to the remote branch are not in conflict with your changes, this process will move seamlessly.\n\n\nWhen conflicts need fixing\n\n\nLet's say another writer working on \nnew-branch\n changed the title of a document and then pushed her changes to the remote branch. Meanwhile, you also changed the title of that same document on your copy of \nnew-branch\n. When you \ngit push\n your changes to remote, you see a conflict error as above. So you try the \nfetch\n, \nmerge\n, \npush\n. The real problem comes when you run \nmerge\n:\n\n\ngit fetch\ngit merge\nAuto-merging docs/\nyour-document\n.htm\nCONFLICT \n(\ncontent\n)\n: Merge conflict in docs/\nyour-document\n.htm\nAutomatic merge failed\n;\n fix conflicts and \nthen\n commit the result.\n\n\n\n\nGit won't let you merge because you'd be changing the other writer's commit. So, how do you proceed?\n\n\nWell, you want to see the conflict and decide what to do. The simplest solution is to use a text editor like VS Code (or Atom, Notepad++, Sublime, etc.) to see te changes.\n\n\n\n\nOpen the conflict document (\\\nyour-document>.htm) in a text editor.\n\n\nThe conflict should be indicated:\n    \n HEAD (Current Change)\n# Pushing and Pulling\n=======\n# Pushing and Pulling example\n\n refs/remotes/origin/new-branch (Incoming Change)\n\n\n    Current change is your version. Incoming change is the remote version. Here we can see the conflict: both writers made changes to       the title.\n\n\nCorrect the change by deleting the \\\n,>,=, HEAD, and the content that you don't want to keep, or integrate both changes.\n    I want to keep the current change so my document will look like this:\n    \n# Pushing and Pulling\n\n\n\n\n\nNow, we need to \nstage\n, \ncommit\n, and \npush\n.\n\n\ngit add --all \n#--all just means stage any and all changed files\n\ngit commit -m \nfixed conflicts\n\ngit push\ngit show-ref new-branch\nebca4258650049a273e9a67b3fb9aad8aa70af22 refs/heads/new-branch\nebca4258650049a273e9a67b3fb9aad8aa70af22 refs/remotes/origin/new-branch\n\n\n\n\nNow we can see that the remote and local branches are up-to-date and pointing to the same commit. And that is what we want.", 
            "title": "Merge Conflicts"
        }, 
        {
            "location": "/conflicts/#conflicts", 
            "text": "Merge conflicts can happen when:   You merge changes where a document(s) are in conflict.  Edit a file that as been deleted.   Sometimes, things can become messy when many people are working on the same stuff. Fixing conflicts is pretty easy though, especially with the right tools.  On a single branch, each subsequent commit replaces the previous.  A---B---C---D ... (feature-a)  When you merge, conflicts can happen.  A---B---C---G (feature-a-albin)\n\\          /\n D---E----F (feature-a-tove)  If the same file has changed on both branches, which version, F or C, is correct when you merge to create G?", 
            "title": "Conflicts"
        }, 
        {
            "location": "/conflicts/#conflicts-with-sourcetree", 
            "text": "Let's say we have two writers, Albin and Tove, and they are working together on a new product scenario. They both edit the same file, and there is a conflict when one of them merges the two branches.     Tove change  Albin Change           Let's say that Tove wants to merge Albin's branch with hers. When Tove clicks  Merge , she sees a merge conflict error. There are several ways to solve the conflict.", 
            "title": "Conflicts with Sourcetree"
        }, 
        {
            "location": "/conflicts/#simple-resolution-using-mine-vs-theirs", 
            "text": "Click the file and look at the File diff window.   The conflict is highlighted by angle brackets ( , ) and the the two conflicts are separated by equal signs (=).  Tove can choose which change to keep using the  mine  or  theirs  method.   Right-click the staged file.   Select  Resolve Conflicts .\n    A dialog opens.     Select  Resolve Using 'Mine'  to keep the current branch version.  (or) Select  Resolve Using 'Theirs'  to keep the other version.  Let's keep Albin's version for this example.     Tip  If you can't remember which resolution method to use, don't worry! When you select either option, a dialog opens before resolving the conflict asking you if you want to keep the file from commit number X.    You can verify the commit you want to keep by using the hash. We can see Albin's version is from commit  bd4f62d .     Select  OK .  You'll see a merge commit in the Sourcetree graph that is uncommited.    Select  Commit  from the ribbon.    Enter a merge commit message.  There will be some auto-generated message about the conflict resolution.    The conflict is resolved. You can now safely delete unused branches.", 
            "title": "Simple resolution using Mine vs. Theirs"
        }, 
        {
            "location": "/conflicts/#using-an-external-merge-tool", 
            "text": "Solving a conflict might not always be as easy as picking mine or theirs. Sometimes you'll need to customize the merge. This is also easy with a simple text editor.  Let's go through a complex and likely scenario.   Both Albin and Tove are working on a DataMarket feature.  They both create a feature branch.  They both change the same file.  They update the TOC.  They update the target.   When they merge, they will have several conflicts, possibly in  htm  files, and in  fltoc  and  fltar  files.  Let's look at where our writers are at.   Each writer branch has its own commit history.  Let's say that Tove is responsible for delivering this feature, so she merges Albin's branch with hers. The TOC does not produce a conflict even though they both changed it. This is because each other's changes do not conflict with the other.  When Tove clicks on the conflict target file, she sees exactly what is conflicting.", 
            "title": "Using an external merge tool"
        }, 
        {
            "location": "/conflicts/#fixing-the-target-conflict", 
            "text": "The change in the green box is not in conflict (there are no conflict characters  , ,=).  The first red box shows that the stylesheet was changed on both branches. The second red box shows a new line  UseDeviceWidth =\"true\" .  Info You can't solve this merge conflict in Flare and you might see an error message in Flare when you get a merge conflict. You can just close it. Since target files are mostly just config settings or text fields, using a  mine  or  theirs  strategy will work for solving these types of errors, since you'll never want to combine changes. But, to make this example more complicated than it needs to be, I'll choose one of changes from each branch which will force me to use an external tool.   I want to use the common_print.css stylesheet  I want to use the device width setting.   The best option is to open the file in a text editor and make the change manually.  Tove opens the file in VS Code.   With VS Code, Tove selects which changes to keep and then saves the file. She goes back to Sourcetree. The target conflicts are gone.", 
            "title": "Fixing the target conflict"
        }, 
        {
            "location": "/conflicts/#fixing-the-htm-conflict", 
            "text": "Tove will fix the htm file in the exact same way. She opens the file in VS Code. She select which changes to keep. She saves the file, and then she goes back to Sourcetree.", 
            "title": "Fixing the htm conflict"
        }, 
        {
            "location": "/conflicts/#finishing-the-commit", 
            "text": "Tove still has the same files in both  staged  and  unstaged  areas. She needs to clean up before the commit.    Select  Stage All .  The  unstaged  files will disappear.    Select  Commit  from the ribbon.    Tove will build locally and verify the changes before deleting unused branches.", 
            "title": "Finishing the commit"
        }, 
        {
            "location": "/conflicts/#fringe-case-deleted-files", 
            "text": "Tove deleted a file called New Text Document. Albin didn't know and was editing this document on his branch. When Tove merged Albin's branch, there was a merge conflict for the deleted file.  Sourcetree will not show a conflict in file diff area because a diff requires two files. Currently there is only a file on  albin-branch . Tove cannot resolve using a  mine - theirs  strategy because the file does not exist. If she selects  mine  (meaning hers), Sourcetree throws an error.  Assuming there are other changes on Albin's branch that Tove wants to keep, she will right-click the deleted file and select  Remove . This should remove it from all file areas in Sourcetree.  Tove can now commit the remaing changes and merge.", 
            "title": "Fringe case: deleted files"
        }, 
        {
            "location": "/conflicts/#conflicts-with-git-bash", 
            "text": "Recommendation Read the Sourcetree example which goes into more detail about the conflicts. The GUI will help you visuzalize what is happening with a conflict. Let's say I  git push  and I get an error like the following:  git push\nTo https://github.com/qlik-trial/omni-project.git\n !  [ rejected ]           new-branch -  new-branch  ( fetch first ) \nerror: failed to push some refs to  https://github.com/qlik-trial/omni-project.git \nhint: Updates were rejected because the remote contains work that you  do \nhint: not have locally. This is usually caused by another repository pushing\nhint: to the same ref. You may want to first integrate the remote changes\nhint:  ( e.g.,  git pull ... )  before pushing again.\nhint: See the  Note about fast-forwards  in  git push --help   for  details.  Git is saying that I can't  push  because the remote copy of the branch has diverged -- it has content that I don't have on my local branch. It is also telling me that I need to  fetch  first. So let's do that.  What we want to do is:   Fetch the changes from remote.  Merge those changes with local.  Push our changes to remote.   git fetch\ngit merge\ngit push  If the changes that someone else pushed to the remote branch are not in conflict with your changes, this process will move seamlessly.", 
            "title": "Conflicts with Git Bash"
        }, 
        {
            "location": "/conflicts/#when-conflicts-need-fixing", 
            "text": "Let's say another writer working on  new-branch  changed the title of a document and then pushed her changes to the remote branch. Meanwhile, you also changed the title of that same document on your copy of  new-branch . When you  git push  your changes to remote, you see a conflict error as above. So you try the  fetch ,  merge ,  push . The real problem comes when you run  merge :  git fetch\ngit merge\nAuto-merging docs/ your-document .htm\nCONFLICT  ( content ) : Merge conflict in docs/ your-document .htm\nAutomatic merge failed ;  fix conflicts and  then  commit the result.  Git won't let you merge because you'd be changing the other writer's commit. So, how do you proceed?  Well, you want to see the conflict and decide what to do. The simplest solution is to use a text editor like VS Code (or Atom, Notepad++, Sublime, etc.) to see te changes.   Open the conflict document (\\ your-document>.htm) in a text editor.  The conflict should be indicated:\n      HEAD (Current Change)\n# Pushing and Pulling\n=======\n# Pushing and Pulling example  refs/remotes/origin/new-branch (Incoming Change) \n    Current change is your version. Incoming change is the remote version. Here we can see the conflict: both writers made changes to       the title.  Correct the change by deleting the \\ ,>,=, HEAD, and the content that you don't want to keep, or integrate both changes.\n    I want to keep the current change so my document will look like this:\n     # Pushing and Pulling   Now, we need to  stage ,  commit , and  push .  git add --all  #--all just means stage any and all changed files \ngit commit -m  fixed conflicts \ngit push\ngit show-ref new-branch\nebca4258650049a273e9a67b3fb9aad8aa70af22 refs/heads/new-branch\nebca4258650049a273e9a67b3fb9aad8aa70af22 refs/remotes/origin/new-branch  Now we can see that the remote and local branches are up-to-date and pointing to the same commit. And that is what we want.", 
            "title": "When conflicts need fixing"
        }, 
        {
            "location": "/history/", 
            "text": "Git History\n\n\nUse Git Bash to find, change, and reorganize git history.\n\n\nThe git graph\n\n\n\n\n\n\n\n\ncommand\n\n\nargument\n\n\ndescription\n\n\n\n\n\n\n\n\n\n\ngit log\n\n\n--\n\n\nPrints out the commit history in a list.\n\n\n\n\n\n\n\n\n--graph\n\n\nPrints an ASCII graph\n\n\n\n\n\n\n\n\n--decorate\n\n\nShows the positional references: HEAD, branch\n\n\n\n\n\n\n\n\n--oneline\n\n\nFormats log to single line\n\n\n\n\n\n\n\n\n\n\nShow a commit\n\n\n\n\n\n\n\n\ncommand\n\n\nargument\n\n\ndescription\n\n\n\n\n\n\n\n\n\n\ngit show \nsomething\n\n\n--\n\n\nPrints out info about a commit\n\n\n\n\n\n\n\n\nsha1\n\n\nShow the commit referenced by the SHA1\n\n\n\n\n\n\n\n\nbranch\n\n\nShows the commit that the branch is pointing to\n\n\n\n\n\n\n\n\nHEAD\n\n\nShows the commit that the HEAD is pointing to\n\n\n\n\n\n\n\n\nIn the image above, \nHEAD\n and \nfeature/HLP-3162\n and \ncc67576a\n all point to the same commit.\n\n\nThe following commands print the same results:\n\n\ngit show HEAD\n\n#OR\n\ngit show \n`\nfeature/HLP-3162\n`\n\n\n#OR\n\ngit show \n`\ncc67576a\n`\n\n\ncommit cc67576a7142c77d3969666cf277ecdf741c8273 \n(\nHEAD -\n feature/HLP-3162\n)\n\nAuthor: kyleweishaar \nkyle.weishaar@qlik.com\n\nDate:   Tue Jul \n3\n \n11\n:59:56 \n2018\n -0400\n\n    save all\n\ndiff --git a/Project/Targets/Sense_Hub/dev_share_scripting.fltar b/Project/Targets/Sense_Hub/dev_share_scripting.fltar\nindex \n39644002\n..423cb586 \n100644\n\n--- a/Project/Targets/Sense_Hub/dev_share_scripting.fltar\n+++ b/Project/Targets/Sense_Hub/dev_share_scripting.fltar\n@@ -5,10 +5,16 @@\n   \nType\n=\nCleanXHTML\n\n   \nDestinations\n=\n\n   \nGlossaryTermConversion\n=\nmarked\n\n-  \nMasterToc\n=\n/Project/TOCs/Sense_Hub/ScriptingModule.fltoc\n\n+  \nMasterToc\n=\n/Project/TOCs/Sense_Hub/ScriptingModule.fltoc\n\n+  \nOutputFolder\n=\nC:\\git\\content-share\n\n   \nPrintedOutput\n     \nCollapseMargins\n=\ntrue\n\n     \nGenerateTOCProxy\n=\ntrue\n\n     \nGenerateIndexProxy\n=\ntrue\n\n     \nGenerateGlossaryProxy\n=\ntrue\n /\n\n+  \nDestinations\n\n+    \nDestination\n+      \nLink\n=\n/Project/Destinations/git_hub.fldes\n\n+      \nPublish\n=\ntrue\n /\n\n+  \n/Destinations\n\n \n/CatapultTarget\n\n\n\\ \nNo newline at end of file", 
            "title": "Git log"
        }, 
        {
            "location": "/history/#git-history", 
            "text": "Use Git Bash to find, change, and reorganize git history.", 
            "title": "Git History"
        }, 
        {
            "location": "/history/#the-git-graph", 
            "text": "command  argument  description      git log  --  Prints out the commit history in a list.     --graph  Prints an ASCII graph     --decorate  Shows the positional references: HEAD, branch     --oneline  Formats log to single line", 
            "title": "The git graph"
        }, 
        {
            "location": "/history/#show-a-commit", 
            "text": "command  argument  description      git show  something  --  Prints out info about a commit     sha1  Show the commit referenced by the SHA1     branch  Shows the commit that the branch is pointing to     HEAD  Shows the commit that the HEAD is pointing to     In the image above,  HEAD  and  feature/HLP-3162  and  cc67576a  all point to the same commit.  The following commands print the same results:  git show HEAD #OR \ngit show  ` feature/HLP-3162 `  #OR \ngit show  ` cc67576a ` \n\ncommit cc67576a7142c77d3969666cf277ecdf741c8273  ( HEAD -  feature/HLP-3162 ) \nAuthor: kyleweishaar  kyle.weishaar@qlik.com \nDate:   Tue Jul  3   11 :59:56  2018  -0400\n\n    save all\n\ndiff --git a/Project/Targets/Sense_Hub/dev_share_scripting.fltar b/Project/Targets/Sense_Hub/dev_share_scripting.fltar\nindex  39644002 ..423cb586  100644 \n--- a/Project/Targets/Sense_Hub/dev_share_scripting.fltar\n+++ b/Project/Targets/Sense_Hub/dev_share_scripting.fltar\n@@ -5,10 +5,16 @@\n    Type = CleanXHTML \n    Destinations = \n    GlossaryTermConversion = marked \n-   MasterToc = /Project/TOCs/Sense_Hub/ScriptingModule.fltoc \n+   MasterToc = /Project/TOCs/Sense_Hub/ScriptingModule.fltoc \n+   OutputFolder = C:\\git\\content-share \n    PrintedOutput\n      CollapseMargins = true \n      GenerateTOCProxy = true \n      GenerateIndexProxy = true \n      GenerateGlossaryProxy = true  / \n+   Destinations \n+     Destination\n+       Link = /Project/Destinations/git_hub.fldes \n+       Publish = true  / \n+   /Destinations \n  /CatapultTarget  \\  No newline at end of file", 
            "title": "Show a commit"
        }, 
        {
            "location": "/complete/", 
            "text": "A complete workflow\n\n\nThe other topics should have given you a good foundation for running some of the many git processes in Git Bash and Git Extension. This topic will cover a more highlevel workflow without going too much into the small details which are covered in other topics. When referring to git actions, I will use the command name (ex. \ngit merge\n), but you can do the action with the Git Extensions.\n\n\n\n\nInfo\n\n\n** marks a step that pulls content from the remote to your local branch. Pay attention to when you should run \ngit pull\n.\n\n\n\n\nCreate a local branch\n\n\nYou create branches to isolate work. When you create a branch, it exists on your machine only. I refer to these branches as \nlocal\n branches because they are local to you. You should not run \ngit push\n or \ngit pull\n on local branches, since these commands interface between your local repo and the remote repo.\n\n\nNaming\n\n\n\n\n\n\nfeature/HLP-XXXX\n\n\n\n\n\n\nfeature/PS-XXXX\n\n\n\n\n\n\nbug/HLP-XXXX\n\n\n\n\n\n\ncleanup/name\n\n\n\n\n\n\nScenario\n\n\nYou want to create a branch.\n\n\n\n\n\n\ngit checkout daily\n\n\n\n\n\n\ngit pull\n **\n\n\n\n\n\n\ngit branch branch-name\n (creates a branch) ... OR ...\n\n\ngit checkout -b branch-name\n (creates and checkouts branch)\n\n\n\n\n\n\nCommit your work\n\n\nCommitting means adding content to a repository. When you are on a branch, you modify files, you stage the modifications, then you commit those modifications to the local repository.\n\n\nScenario\n\n\nYou edit some files in Flare.\n\n\n\n\n\n\ngit status\n (to list the modified files that are in the working area)\n\n\n\n\n\n\ngit add \nfile-name\n ... OR ...\n\n\n\n\n\n\ngit add --all\n (adds all files in the working area)\n\n\n\n\n\n\ngit commit -m \"a good commit message\"\n\n\n\n\n\n\nMerge your branch\n\n\nMerging means bringing the commit history from one branch into another branch. We merge local branches into shared branches.\n\n\nScenario\n\n\nYou want to merge your local branch to \ndaily\n.\n\n\n\n\n\n\ngit checkout daily\n\n\n\n\n\n\ngit pull\n **\n\n\n\n\n\n\ngit merge \nfeature-branch\n\n\n\n\n\n\nKeeping in sync\n\n\nKeeping in sync means making sure that your local copies of the \nmaster\n and \ndaily\n branches have the latest content. Whenever you checkout a shared branch (\nmaster\n or \ndaily\n), you \nmust\n run \ngit pull\n first.\n\n\nScenarios\n\n\nYou want to merge your feature with \ndaily\n so you can check the output with Jenkins\n\n\n\n\n\n\ngit checkout daily\n\n\n\n\n\n\ngit pull\n **\n\n\n\n\n\n\ngit merge feature/branch\n\n\n\n\n\n\ngit push\n **\n\n\n\n\n\n\nYou want to cherry-pick your feature to \nmaster\n\n\n\n\n\n\ngit checkout master\n\n\n\n\n\n\ngit pull\n **\n\n\n\n\n\n\ngit merge --squash feature/branch\n\n\n\n\n\n\ngit add \nfile-name\n ... OR ...\n\n\n\n\n\n\ngit add --all\n (adds all files in the working area)\n\n\n\n\n\n\ngit commit -m \"a good commit message\"\n\n\n\n\n\n\ngit push\n **\n\n\n\n\n\n\nYou have a long running feature. You want to update your local branch with new content from \ndaily\n\n\nHow do we sync our \nlocal\n branch with a remote branch?\n\n\n\n\nTip\n\n\nThe \ngit pull\n step is very important here. If you rebase a daily that is not up-to-date, you'll get into trouble later on.\n\n\n\n\n\n\n\n\n\n\ngit checkout daily\n\n\n\n\n\n\ngit pull\n **\n\n\n\n\n\n\ngit checkout feature/branch\n\n\n\n\n\n\ngit rebase daily\n\n\n\n\n\n\n\n\n\n\nTip\n\n\nCompare the two graph images. Notice what happens when you rebase \ndaily\n \nonto\n your feature branch. Git \nrewinds\n the head of your feature branch, then adds the commits from daily and then places your commit at the top.\n\n\n\n\nMore complex example\n\n\nRebasing daily onto your local branch works even when there are more than one branches involved. The image below shows a likely scenario:\n\n\n\n\n\n\nSome other writer has a local branch and they are merging to \ndaily\n.\n\n\n\n\n\n\nThe \ndaily\n branch has commits on it that are not part of your local branch.\n\n\n\n\n\n\nYou are working on a local branch and have been merging to \ndaily\n.\n\n\n\n\n\n\n\n\nTip\n\n\nDon't necessarily rebase all the time. I would restrict this to times when you know there is work that you need to grab from daily that was added after you branched off of \ndaily\n, or when you are working with another writer on a feature/area.\n\n\n\n\n\n\nWarning\n\n\nPay attention to what you are doing! Do not rebase onto shared branches. This increases the risk of having unwanted merge conflicts. Before rebasing, make sure you know what branch you have checked out.\n\n\n\n\n\n\n\n\n\n\ngit checkout daily\n\n\n\n\n\n\ngit pull\n **\n\n\n\n\n\n\ngit checkout feature/branch\n\n\n\n\n\n\ngit rebase daily\n\n\n\n\n\n\nThe result is the image below. Note that \ndaily\n and \nkyle\n point to the same commit which shows you that \nkyle\n has all of the content from the two parents: 1 from the running \ndaily\n branch and the other from \nother-writer\n.\n\n\n\n\nSummary\n\n\n\n\n\n\nUse \ngit pull\n whenever you interact with a shared branch. Even if you \nthink\n there is nothing new, get into the habit of pulling often. This is how you grab other writers work \nbefore\n you create a branch.\n\n\n\n\n\n\nUse \ngit merge\n to add content from your feature branch into \ndaily\n. Do this when you want to see the build output from Jenkins. Once you merge into \ndaily\n, other writers can see this content.\n\n\n\n\n\n\nUse \ngit rebase\n when you need to grab \nnewer\n content from \ndaily\n to bring it into your feature branch. This is how you manage to keep your local branch content from diverging too much from the \ndaily\n branch. This is probably not required for short lived features or if the area you are working in is not changing often.\n\n\n\n\n\n\nBuild in Jenkins\n\n\nTo build the output, Jenkins looks at the \ndaily\n branch on github.com. The Jenkins build environment asks you to select the product to build, which area or areas of that product's help site, and the branch to build from. The \ndaily\n branch is what you will build most often.\n\n\nSquash and cherry-pick\n\n\nThe \nmaster\n branch is a \nclean\n branch that we use to create release branches. This branch contains complete work that can be included in a release. \n\n\nWe want to avoid having a messy commit history on \nmaster\n by cherry-picking features, bugs, and cleanup work, onto \nmaster\n.\n\n\nThink of it like this:\n\n\n\n\n\n\nA merge commit results in a history of at least 2 commits:\n\n\n\n\n\n\n1 merge commit (E).\n\n\n\n\n\n\n1 commit from the branch being merged (B).\n\n\n\n\n\n\n    B\n     \\\nC--D--E (daily)\n\n\n\n\n\n\n\n\nIf the branch has many commits, then the number of commits in the branch history will be the number of commits + 1 merge commit.\n\n\n\n\n\n\nIf 14 writers merge 14 branches with 6 commits on each branch, then the commit history for 14 branches (maybe 14 features) results in 98 commits (14branches *7commits).\n\n\n\n\n\n\nTwo git actions\n\n\nSquash\n\n\nThis means to take 1+ commits and turn them into a single commit. A squash changes commits, therefore git is rewriting history.\n\n\nCherry-pick\n\n\nThis means to take a single commit and add it to the tip of a branch without making a merge commit.\n\n\nScenario\n\n\nYou have tested your feature on the \ndaily\n branch + Jenkins build. No more work needs to be done.\n\n\n\n\n\n\ngit checkout master\n\n\n\n\n\n\ngit pull\n **\n\n\n\n\n\n\ngit merge --squash \nfeature-branch\n\n\nThis command does not do a merge commit. The \n--squash\n option takes all of the modified files from all of the commits on the branch and puts them into the working area on \nmaster\n.\n\n\n\n\n\n\ngit add --all\n\n\n\n\n\n\ngit commit -m \"Squash + cherry-pick feature-xxxx to master\"\n\n\n\n\n\n\ngit push\n\n\n\n\n\n\nWriter's checklist\n\n\nThe writer's checklist refers to the steps from start to finish. A feature is finished when the feature has been cherry-picked to \nmaster\n and the local branch is deleted. You should have a checklist whenever you create a new branch.\n\n\nExample checklist\n\n\nFor each feature/bug/documentation task:\n\n\n\n\n\n\nI create a branch from \ndaily\n.\n\n\n\n\n\n\nI label the branch according to the naming convention.\n\n\n\n\n\n\nI make sure that I have my branch checked out.\n\n\n\n\n\n\nI do my work and commit my work to my local branch.\n\n\n\n\n\n\nI merge my branch to daily, I push daily to the remote, I run a build from Jenkins.\n\n\n\n\n\n\nWhen my work is finished, I make sure my branch is merged to daily.\n\n\n\n\n\n\nI squash my commits into a single commit.\n\n\n\n\n\n\nI cherry-pick that single commit to \nmaster\n.\n\n\n\n\n\n\nI delete my local branch.", 
            "title": "Complete Workflow"
        }, 
        {
            "location": "/complete/#a-complete-workflow", 
            "text": "The other topics should have given you a good foundation for running some of the many git processes in Git Bash and Git Extension. This topic will cover a more highlevel workflow without going too much into the small details which are covered in other topics. When referring to git actions, I will use the command name (ex.  git merge ), but you can do the action with the Git Extensions.   Info  ** marks a step that pulls content from the remote to your local branch. Pay attention to when you should run  git pull .", 
            "title": "A complete workflow"
        }, 
        {
            "location": "/complete/#create-a-local-branch", 
            "text": "You create branches to isolate work. When you create a branch, it exists on your machine only. I refer to these branches as  local  branches because they are local to you. You should not run  git push  or  git pull  on local branches, since these commands interface between your local repo and the remote repo.", 
            "title": "Create a local branch"
        }, 
        {
            "location": "/complete/#naming", 
            "text": "feature/HLP-XXXX    feature/PS-XXXX    bug/HLP-XXXX    cleanup/name", 
            "title": "Naming"
        }, 
        {
            "location": "/complete/#scenario", 
            "text": "You want to create a branch.    git checkout daily    git pull  **    git branch branch-name  (creates a branch) ... OR ...  git checkout -b branch-name  (creates and checkouts branch)", 
            "title": "Scenario"
        }, 
        {
            "location": "/complete/#commit-your-work", 
            "text": "Committing means adding content to a repository. When you are on a branch, you modify files, you stage the modifications, then you commit those modifications to the local repository.", 
            "title": "Commit your work"
        }, 
        {
            "location": "/complete/#scenario_1", 
            "text": "You edit some files in Flare.    git status  (to list the modified files that are in the working area)    git add  file-name  ... OR ...    git add --all  (adds all files in the working area)    git commit -m \"a good commit message\"", 
            "title": "Scenario"
        }, 
        {
            "location": "/complete/#merge-your-branch", 
            "text": "Merging means bringing the commit history from one branch into another branch. We merge local branches into shared branches.", 
            "title": "Merge your branch"
        }, 
        {
            "location": "/complete/#scenario_2", 
            "text": "You want to merge your local branch to  daily .    git checkout daily    git pull  **    git merge  feature-branch", 
            "title": "Scenario"
        }, 
        {
            "location": "/complete/#keeping-in-sync", 
            "text": "Keeping in sync means making sure that your local copies of the  master  and  daily  branches have the latest content. Whenever you checkout a shared branch ( master  or  daily ), you  must  run  git pull  first.", 
            "title": "Keeping in sync"
        }, 
        {
            "location": "/complete/#scenarios", 
            "text": "", 
            "title": "Scenarios"
        }, 
        {
            "location": "/complete/#you-want-to-merge-your-feature-with-daily-so-you-can-check-the-output-with-jenkins", 
            "text": "git checkout daily    git pull  **    git merge feature/branch    git push  **", 
            "title": "You want to merge your feature with daily so you can check the output with Jenkins"
        }, 
        {
            "location": "/complete/#you-want-to-cherry-pick-your-feature-to-master", 
            "text": "git checkout master    git pull  **    git merge --squash feature/branch    git add  file-name  ... OR ...    git add --all  (adds all files in the working area)    git commit -m \"a good commit message\"    git push  **", 
            "title": "You want to cherry-pick your feature to master"
        }, 
        {
            "location": "/complete/#you-have-a-long-running-feature-you-want-to-update-your-local-branch-with-new-content-from-daily", 
            "text": "How do we sync our  local  branch with a remote branch?   Tip  The  git pull  step is very important here. If you rebase a daily that is not up-to-date, you'll get into trouble later on.      git checkout daily    git pull  **    git checkout feature/branch    git rebase daily      Tip  Compare the two graph images. Notice what happens when you rebase  daily   onto  your feature branch. Git  rewinds  the head of your feature branch, then adds the commits from daily and then places your commit at the top.", 
            "title": "You have a long running feature. You want to update your local branch with new content from daily"
        }, 
        {
            "location": "/complete/#more-complex-example", 
            "text": "Rebasing daily onto your local branch works even when there are more than one branches involved. The image below shows a likely scenario:    Some other writer has a local branch and they are merging to  daily .    The  daily  branch has commits on it that are not part of your local branch.    You are working on a local branch and have been merging to  daily .     Tip  Don't necessarily rebase all the time. I would restrict this to times when you know there is work that you need to grab from daily that was added after you branched off of  daily , or when you are working with another writer on a feature/area.    Warning  Pay attention to what you are doing! Do not rebase onto shared branches. This increases the risk of having unwanted merge conflicts. Before rebasing, make sure you know what branch you have checked out.      git checkout daily    git pull  **    git checkout feature/branch    git rebase daily    The result is the image below. Note that  daily  and  kyle  point to the same commit which shows you that  kyle  has all of the content from the two parents: 1 from the running  daily  branch and the other from  other-writer .", 
            "title": "More complex example"
        }, 
        {
            "location": "/complete/#summary", 
            "text": "Use  git pull  whenever you interact with a shared branch. Even if you  think  there is nothing new, get into the habit of pulling often. This is how you grab other writers work  before  you create a branch.    Use  git merge  to add content from your feature branch into  daily . Do this when you want to see the build output from Jenkins. Once you merge into  daily , other writers can see this content.    Use  git rebase  when you need to grab  newer  content from  daily  to bring it into your feature branch. This is how you manage to keep your local branch content from diverging too much from the  daily  branch. This is probably not required for short lived features or if the area you are working in is not changing often.", 
            "title": "Summary"
        }, 
        {
            "location": "/complete/#build-in-jenkins", 
            "text": "To build the output, Jenkins looks at the  daily  branch on github.com. The Jenkins build environment asks you to select the product to build, which area or areas of that product's help site, and the branch to build from. The  daily  branch is what you will build most often.", 
            "title": "Build in Jenkins"
        }, 
        {
            "location": "/complete/#squash-and-cherry-pick", 
            "text": "The  master  branch is a  clean  branch that we use to create release branches. This branch contains complete work that can be included in a release.   We want to avoid having a messy commit history on  master  by cherry-picking features, bugs, and cleanup work, onto  master .  Think of it like this:    A merge commit results in a history of at least 2 commits:    1 merge commit (E).    1 commit from the branch being merged (B).        B\n     \\\nC--D--E (daily)    If the branch has many commits, then the number of commits in the branch history will be the number of commits + 1 merge commit.    If 14 writers merge 14 branches with 6 commits on each branch, then the commit history for 14 branches (maybe 14 features) results in 98 commits (14branches *7commits).", 
            "title": "Squash and cherry-pick"
        }, 
        {
            "location": "/complete/#two-git-actions", 
            "text": "", 
            "title": "Two git actions"
        }, 
        {
            "location": "/complete/#squash", 
            "text": "This means to take 1+ commits and turn them into a single commit. A squash changes commits, therefore git is rewriting history.", 
            "title": "Squash"
        }, 
        {
            "location": "/complete/#cherry-pick", 
            "text": "This means to take a single commit and add it to the tip of a branch without making a merge commit.", 
            "title": "Cherry-pick"
        }, 
        {
            "location": "/complete/#scenario_3", 
            "text": "You have tested your feature on the  daily  branch + Jenkins build. No more work needs to be done.    git checkout master    git pull  **    git merge --squash  feature-branch  This command does not do a merge commit. The  --squash  option takes all of the modified files from all of the commits on the branch and puts them into the working area on  master .    git add --all    git commit -m \"Squash + cherry-pick feature-xxxx to master\"    git push", 
            "title": "Scenario"
        }, 
        {
            "location": "/complete/#writers-checklist", 
            "text": "The writer's checklist refers to the steps from start to finish. A feature is finished when the feature has been cherry-picked to  master  and the local branch is deleted. You should have a checklist whenever you create a new branch.", 
            "title": "Writer's checklist"
        }, 
        {
            "location": "/complete/#example-checklist", 
            "text": "For each feature/bug/documentation task:    I create a branch from  daily .    I label the branch according to the naming convention.    I make sure that I have my branch checked out.    I do my work and commit my work to my local branch.    I merge my branch to daily, I push daily to the remote, I run a build from Jenkins.    When my work is finished, I make sure my branch is merged to daily.    I squash my commits into a single commit.    I cherry-pick that single commit to  master .    I delete my local branch.", 
            "title": "Example checklist"
        }, 
        {
            "location": "/sourcetreeworkflow/", 
            "text": "Simple Workflow using Sourcetree\n\n\nPrerequisites\n\n\nMake sure you have everything installed and set up so you can follow along with this tutorial.\n\n\n\n\nGet Git\n\n\n\n\nCreate a personal git repository on GitHub.\n\n\nOverview\n\n\nThe steps involved in a basic workflow look like this:\n\n\nInfo\nThis table is taken from \nSimple workflow using Git Bash\n, but we need to do the same thing with Sourcetree. In the end, you'll see that it is simpler to use the GUI as we can combine some of our git commands.\n\n\n\n\n\n\nStep\n\n\ngit command\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n1\n\n\ngit pull\n\n\nGrabs any changes from remote for your checked out branch.\n\n\n\n\n\n\n2\n\n\ngit branch \nnew-branch\n\n\nCreates a new branch from your checked out branch.\n\n\n\n\n\n\n3\n\n\n--\n\n\nDo your work, edit a file, etc.\n\n\n\n\n\n\n4\n\n\ngit status\n\n\nCheck your branch status. You'll see the files that you are working on in red.\n\n\n\n\n\n\n6\n\n\ngit add \nfile\n\n\nStage the working files. \nfile\n is the name of the file, ex. \nfile.htm\n.\nTo add \nall\n files, use \ngit add .\n or git \nadd --all\n\n\n\n\n\n\n7\n\n\ngit status\n\n\nCheck your staged files. You'll see the staged files in green.\n\n\n\n\n\n\n8\n\n\ngit commit -m \"commit message\"\n\n\nAppends a message to this commit\n\n\n\n\n\n\n9\n\n\ngit push\n\n\nPushes your committed files to the remote branch.\n\n\n\n\n\n\n\n\nPreamble\n\n\nFor these work instructions, I created an \nexamples\n repository. Feel free to create a repo on your personal GitHub account to play with.\n\n\n\n\nUnder \nBranches\n, I have a single \nmaster\n branch. The graph shows some previous commits, but we shouldn't concern ourselves with that right now.\n\n\nThe labels on the graph show that our local \nmaster\n and \norigin/master\n are pointing to the same commit (they are in sync) and the \norigin/HEAD\n is pointing the the latest commit. If I don't want to see the labels for remote branches, I deselect \nShow Remote Branches\n.\n\n\nBranching\n\n\nBefore you begin, click \nPull\n in the ribbon to make sure that your current branch grabs any changes that are sitting on the remote that are not on your local branch. No one else is working in this repo so there won't be any changes. However, in our omni-project, we'll all be working in the same repo, so this is just good practice.\n\n\nTo create a new branch:\n\n\n\n\nClick the branch button in the ribbon.\n\n\nName your branch. The name should be lower case and use hyphens for spaces, for example: \nnew-branch-name\n (I named my branch \ndevelop\n.)\n\n\nSelect \nWorking copy parent\n to create a branch based on the latest commit.\n Or select \nSpecified commit\n to create a branch from a specific commit.\n\n\nSelect \nCheckout new branch\n.\nThis will create the branch and then switch from master to your new branch.\n\n\n\n\n\n\nYou'll see the new branch appear in the \nBranches\n section in Sourcetree, and you'll see that it has a small circle beside it (meaning it is checkout).\n\n\nSet upstream branch\n\n\nSo, we've created a branch locally. If this branch is just for personal work that we are not sharing with anyone, you can leave it as is. If you want to push your work to the remote GitHub server, you need to push it upstream to track changes.\n\n\nFor example, \nmaster\n is on your local machine and on GitHub. You make changes locally, commit them to your local branch, and then you push those changes to the remote branch. Let's say that I want to set my branch upstream because I want someone to help me with this feature work.\n\n\n\n\n\n\nClick \nPush\n in the ribbon.\n\n\nThis dialog opens:\n\n\n\n\n\n\n\n\nSelect the new branch.\n\n\nThe name of the remote branch will fill in automatically.\n\n\n\n\n\n\nIn the graph, we can see that all labels (\nmaster\n and \ndevelop\n) point to the exact same commit.\n\n\n\n\nNow work on some content! When you're finished working, we can stage and commit our work.\n\n\nTip\nAdd a couple of text files to your repo.\nStage, commit, and push\n\n\nSourcetree tracks the files that are part of your current branch. When you save your changes, say, to your .htm files in Flare, Sourcetree detects these changes.\n\n\nThe image below shows us that we are on the \ndevelop\n branch. At the top of the graph we have some uncommitted changes, and in the lowest pane, Sourcetree lists the unstaged files. In this case, I created a small markdown file named \ntext\n. It appears in the unstaged file pane.\n\n\n\n\nWe want to do three things:\n\n\n\n\nStage the changed file.\n\n\nCommit the changes to the branch.\n\n\nPush changes from local branch to remote branch.\n\n\n\n\nStage\n\n\nWe want to click on the unstaged file. The pane to the right shows us the changed content (green = content added || red = content removed).\n\n\n\n\n\n\nClick \nStage All\n or \nStage Selected\n.\n\n\nYour unstaged file will move to the staged file pane.\n\n\n\n\n\n\nCommit and push\n\n\nWe want to commit the changes and add a commit message.\n\n\n\n\nClick the \nCommit\n button in the ribbon.\nA text field opens at the bottom.\n\n\nEnter a commit message.\n\n\nSelect \nPush changes immediately to origin/develop\n \n You can commit changes locally without pushing to the remote, but we are using the remote \ndevelop\n branch to backup our work and to collaborate with others, so it is a good idea to push when committing.\n\n\nClick \nCommit\n.\n\n\n\n\nWhere we are at\n\n\nWhen we started, \ndevelop\n and \nmaster\n pointed to the same commit. We switched to the \ndevelop\n branch and did some work, committed that work, and pushed changes to the \norigin/develop\n branch. Let's look at the graph.\n\n\n\n\nmaster\n points to the previous commit. \ndevelop\n is ahead by one. You can continue to work on this branch making small commits often. Every time you commit, you'll see the \ndevelop\n pointer move up to the latest commit. Eventually, you'll want to merge this branch back into \nmaster\n. Merging is covered in the \nMerge with Git Extension\n topic.", 
            "title": "Simple Workflow with Sourcetree"
        }, 
        {
            "location": "/sourcetreeworkflow/#simple-workflow-using-sourcetree", 
            "text": "", 
            "title": "Simple Workflow using Sourcetree"
        }, 
        {
            "location": "/sourcetreeworkflow/#prerequisites", 
            "text": "Make sure you have everything installed and set up so you can follow along with this tutorial.   Get Git   Create a personal git repository on GitHub.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/sourcetreeworkflow/#overview", 
            "text": "The steps involved in a basic workflow look like this:  Info This table is taken from  Simple workflow using Git Bash , but we need to do the same thing with Sourcetree. In the end, you'll see that it is simpler to use the GUI as we can combine some of our git commands.    Step  git command  Description      1  git pull  Grabs any changes from remote for your checked out branch.    2  git branch  new-branch  Creates a new branch from your checked out branch.    3  --  Do your work, edit a file, etc.    4  git status  Check your branch status. You'll see the files that you are working on in red.    6  git add  file  Stage the working files.  file  is the name of the file, ex.  file.htm . To add  all  files, use  git add .  or git  add --all    7  git status  Check your staged files. You'll see the staged files in green.    8  git commit -m \"commit message\"  Appends a message to this commit    9  git push  Pushes your committed files to the remote branch.", 
            "title": "Overview"
        }, 
        {
            "location": "/sourcetreeworkflow/#preamble", 
            "text": "For these work instructions, I created an  examples  repository. Feel free to create a repo on your personal GitHub account to play with.   Under  Branches , I have a single  master  branch. The graph shows some previous commits, but we shouldn't concern ourselves with that right now.  The labels on the graph show that our local  master  and  origin/master  are pointing to the same commit (they are in sync) and the  origin/HEAD  is pointing the the latest commit. If I don't want to see the labels for remote branches, I deselect  Show Remote Branches .", 
            "title": "Preamble"
        }, 
        {
            "location": "/sourcetreeworkflow/#branching", 
            "text": "Before you begin, click  Pull  in the ribbon to make sure that your current branch grabs any changes that are sitting on the remote that are not on your local branch. No one else is working in this repo so there won't be any changes. However, in our omni-project, we'll all be working in the same repo, so this is just good practice.  To create a new branch:   Click the branch button in the ribbon.  Name your branch. The name should be lower case and use hyphens for spaces, for example:  new-branch-name  (I named my branch  develop .)  Select  Working copy parent  to create a branch based on the latest commit.  Or select  Specified commit  to create a branch from a specific commit.  Select  Checkout new branch . This will create the branch and then switch from master to your new branch.    You'll see the new branch appear in the  Branches  section in Sourcetree, and you'll see that it has a small circle beside it (meaning it is checkout).", 
            "title": "Branching"
        }, 
        {
            "location": "/sourcetreeworkflow/#set-upstream-branch", 
            "text": "So, we've created a branch locally. If this branch is just for personal work that we are not sharing with anyone, you can leave it as is. If you want to push your work to the remote GitHub server, you need to push it upstream to track changes.  For example,  master  is on your local machine and on GitHub. You make changes locally, commit them to your local branch, and then you push those changes to the remote branch. Let's say that I want to set my branch upstream because I want someone to help me with this feature work.    Click  Push  in the ribbon.  This dialog opens:     Select the new branch.  The name of the remote branch will fill in automatically.    In the graph, we can see that all labels ( master  and  develop ) point to the exact same commit.   Now work on some content! When you're finished working, we can stage and commit our work.  Tip Add a couple of text files to your repo.", 
            "title": "Set upstream branch"
        }, 
        {
            "location": "/sourcetreeworkflow/#stage-commit-and-push", 
            "text": "Sourcetree tracks the files that are part of your current branch. When you save your changes, say, to your .htm files in Flare, Sourcetree detects these changes.  The image below shows us that we are on the  develop  branch. At the top of the graph we have some uncommitted changes, and in the lowest pane, Sourcetree lists the unstaged files. In this case, I created a small markdown file named  text . It appears in the unstaged file pane.   We want to do three things:   Stage the changed file.  Commit the changes to the branch.  Push changes from local branch to remote branch.", 
            "title": "Stage, commit, and push"
        }, 
        {
            "location": "/sourcetreeworkflow/#stage", 
            "text": "We want to click on the unstaged file. The pane to the right shows us the changed content (green = content added || red = content removed).    Click  Stage All  or  Stage Selected .  Your unstaged file will move to the staged file pane.", 
            "title": "Stage"
        }, 
        {
            "location": "/sourcetreeworkflow/#commit-and-push", 
            "text": "We want to commit the changes and add a commit message.   Click the  Commit  button in the ribbon. A text field opens at the bottom.  Enter a commit message.  Select  Push changes immediately to origin/develop    You can commit changes locally without pushing to the remote, but we are using the remote  develop  branch to backup our work and to collaborate with others, so it is a good idea to push when committing.  Click  Commit .", 
            "title": "Commit and push"
        }, 
        {
            "location": "/sourcetreeworkflow/#where-we-are-at", 
            "text": "When we started,  develop  and  master  pointed to the same commit. We switched to the  develop  branch and did some work, committed that work, and pushed changes to the  origin/develop  branch. Let's look at the graph.   master  points to the previous commit.  develop  is ahead by one. You can continue to work on this branch making small commits often. Every time you commit, you'll see the  develop  pointer move up to the latest commit. Eventually, you'll want to merge this branch back into  master . Merging is covered in the  Merge with Git Extension  topic.", 
            "title": "Where we are at"
        }, 
        {
            "location": "/gitbashworkflow/", 
            "text": "Simple Workflow using Git Bash\n\n\nPrerequisites\n\n\nMake sure you have everything installed and set up so you can follow along with this tutorial.\n\n\n\n\nGet Git\n\n\n\n\nCreate a personal git repository on GitHub.\n\n\nRefresh your CLI skills\n\n\n\n\n\n\nTips for Using Git Bash\n\n\n\n\n\n\nGit Bash Cheat Sheet\n\n\n\n\n\n\nOn your local machine, \ncd\n to the git repo you created for this tutorial.\n\n\ncd\n git/\nname-of-repo\n\n\n\n\n\nInfo\nGit bash probably opens in the Home directory: \nuser/%localhost%\n.\nThe branch that you are on is indicated in parentheses.\n\n\nBDM@usott-bdm MINGW64 /c/git/\nname-of-repo\n \n(\nmaster\n)\n\n\n\n\n\nOverview\n\n\nAn overview of the basic workflow looks like this:\n\n\n\n\n\n\n\n\nStep\n\n\ngit command\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n1\n\n\ngit pull\n\n\nGrabs any changes from remote for your checked out branch.\n\n\n\n\n\n\n2\n\n\ngit branch \nnew-branch\n\n\nCreates a new branch from your checked out branch.\n\n\n\n\n\n\n3\n\n\n--\n\n\nDo your work, edit a file, etc.\n\n\n\n\n\n\n4\n\n\ngit status\n\n\nCheck your branch status. You'll see the files that you are working on in red.\n\n\n\n\n\n\n6\n\n\ngit add \nfile\n\n\nStage the working files. \nfile\n is the name of the file, ex. \nfile.htm\n.\nTo add \nall\n files, use \ngit add .\n or git \nadd --all\n\n\n\n\n\n\n7\n\n\ngit status\n\n\nCheck your staged files. You'll see the staged files in green.\n\n\n\n\n\n\n8\n\n\ngit commit -m \"commit message\"\n\n\nAppends a message to this commit\n\n\n\n\n\n\n9\n\n\ngit push\n\n\nPushes your committed files to the remote branch.\n\n\n\n\n\n\n\n\nPreamble\n\n\nFor these work instructions, I created an \nexamples\n repository. Feel free to create a repo on your personal GitHub account to play with.\n\n\nBranching\n\n\nBefore you begin, run \ngit pull\n to make sure that your current branch grabs any changes that are sitting on the remote that are not on your local branch.\n\n\n\n\n\n\n\n\nCommand\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngit branch \nnew-name\n\n\nCreates a new branch and assigns name to branch.\n\n\n\n\n\n\ngit checkout \nnew-name\n\n\nSwitches from current branch to new branch.\n\n\n\n\n\n\ngit checkout -b \nnew-branch\n\n\nCreates a new branch, assigns a name to it, and switches to it.\n\n\n\n\n\n\ngit branch -d \nnew-name\n\n\nDeletes the branch \nnew-name\n. \n You can't delete the branch that you are on.\n\n\n\n\n\n\n\n\nInfo\nnew-branch\n should be replaced by a name, no brackets or special characters, and no spaces. Naming convention for branches should be to use lowercase and hyphens: \nnew-branch-name\n.\nWhen you create a new branch, it is based on a copy of the branch that you are currently on. So, if you are on master, and you \ngit branch \nnew-branch\n, then \nnew-branch\n is a copy of master.\n\n\nSet upstream branch\n\n\nYou are creating branches locally. If you want to have the branch stored on GitHub so you can keep a backup, share your work, and submit pull requests for others to comment on your work, you need to push the branch to the repository and set it to track the branch upstream (meaning on GitHub).\n\n\n\n\n\n\n\n\nCommand\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngit push --set-upstream origin \nnew-branch\n\n\nPushes the branch to the repository and tells Git to track it. Now, \nnew-branch\n is a branch on your machine and on GitHub.\n\n\n\n\n\n\n\n\nTip\nYou only have to use this command once. Afterwards, \ngit push\n will know where to push the changes.\nWhen you are finished making changes to a file, you'll want to commit those changes. A file has three states in Git, \nunstaged\n (a file that has been changed but not staged), \nstaged\n (a file that is ready to commit), \ncommited\n (a file that is commited to the branch).\n\n\nStage and commit\n\n\n\n\n\n\n\n\nCommand\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngit add \nfile-name\n\n\nTakes a working file and stages it.\n\n\n\n\n\n\ngit commit -m \"some commit message\"\n\n\nCommits the staged files and appends a commit message.\n\n\n\n\n\n\ngit add --all\nor\ngit add .\n\n\nStages all unstaged working files. \n A shortcut to staging each file individually.\n\n\n\n\n\n\n\n\nNow that you have committed your files to your \nnew-branch\n, you'll want to update the branch in GitHub. So far, your git commits are only local commits.\n\n\nPush changes\n\n\n\n\n\n\n\n\nCommand\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngit push\n\n\nPushes your commits to the GitHub repo.\nIf you did not push your branch before and set the origin to track your local branch, you'll receive a note in Git to \ngit push --set-upstream origin \nnew-branch\n. This command only works for branches that have upstream (in GitHub) branches.\n\n\n\n\n\n\n\n\nKeep in mind\n\n\nWhen you are working on a file, you need to make sure that you are working on the appropriate branch. This is because Git changes your working directory based on the branch that you are on.\n\n\nSee \nBranches\n for a more detailed explanation of branches and working directory.\n\n\nStaying in sync\n\n\nAs many people are working in this omni-project, we'll need to make sure that our branches are up-to-date. It is good practice to grab any changes to your branch that have been pushed to the GitHub repo \nbefore\n you push your changes.\n\n\n\n\n\n\n\n\nCommand\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngit pull\n\n\nFetches the changes from a remote branch and merges those changes with your local branch.\n\n\n\n\n\n\ngit fetch\n\n\nFetches the changes from a remote branch.\nfetch\n as the changes to your local repository but does not merge them with your local branch.\n\n\n\n\n\n\ngit merge \nnew-branch\n\n\nWhatever branch you are on, it will take \nnew-branch\n and merge it.\n\n\n\n\n\n\n\n\nIt might be the case that you are working with a colleague who pushes a branch that they created to GitHub, and you want to see it on your machine. Let's say the branch is called \nthors-branch\n. When you do \ngit branch\n you don't see \nthors-branch\n because it hasn't been fetched from remote. You just have to \nfetch\n and then checkout the new branch.\n\n\ngit fetch\nFrom https://github.com/kyleweishaar/examples\n * \n[\nnew branch\n]\n        thors-branch -\n origin/thors-branch\ngit checkout thors-branch", 
            "title": "Simple Workflow with Git Bash"
        }, 
        {
            "location": "/gitbashworkflow/#simple-workflow-using-git-bash", 
            "text": "", 
            "title": "Simple Workflow using Git Bash"
        }, 
        {
            "location": "/gitbashworkflow/#prerequisites", 
            "text": "Make sure you have everything installed and set up so you can follow along with this tutorial.   Get Git   Create a personal git repository on GitHub.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/gitbashworkflow/#refresh-your-cli-skills", 
            "text": "Tips for Using Git Bash    Git Bash Cheat Sheet    On your local machine,  cd  to the git repo you created for this tutorial.  cd  git/ name-of-repo   Info Git bash probably opens in the Home directory:  user/%localhost% . The branch that you are on is indicated in parentheses.  BDM@usott-bdm MINGW64 /c/git/ name-of-repo   ( master )", 
            "title": "Refresh your CLI skills"
        }, 
        {
            "location": "/gitbashworkflow/#overview", 
            "text": "An overview of the basic workflow looks like this:     Step  git command  Description      1  git pull  Grabs any changes from remote for your checked out branch.    2  git branch  new-branch  Creates a new branch from your checked out branch.    3  --  Do your work, edit a file, etc.    4  git status  Check your branch status. You'll see the files that you are working on in red.    6  git add  file  Stage the working files.  file  is the name of the file, ex.  file.htm . To add  all  files, use  git add .  or git  add --all    7  git status  Check your staged files. You'll see the staged files in green.    8  git commit -m \"commit message\"  Appends a message to this commit    9  git push  Pushes your committed files to the remote branch.", 
            "title": "Overview"
        }, 
        {
            "location": "/gitbashworkflow/#preamble", 
            "text": "For these work instructions, I created an  examples  repository. Feel free to create a repo on your personal GitHub account to play with.", 
            "title": "Preamble"
        }, 
        {
            "location": "/gitbashworkflow/#branching", 
            "text": "Before you begin, run  git pull  to make sure that your current branch grabs any changes that are sitting on the remote that are not on your local branch.     Command  Description      git branch  new-name  Creates a new branch and assigns name to branch.    git checkout  new-name  Switches from current branch to new branch.    git checkout -b  new-branch  Creates a new branch, assigns a name to it, and switches to it.    git branch -d  new-name  Deletes the branch  new-name .   You can't delete the branch that you are on.     Info new-branch  should be replaced by a name, no brackets or special characters, and no spaces. Naming convention for branches should be to use lowercase and hyphens:  new-branch-name . When you create a new branch, it is based on a copy of the branch that you are currently on. So, if you are on master, and you  git branch  new-branch , then  new-branch  is a copy of master.", 
            "title": "Branching"
        }, 
        {
            "location": "/gitbashworkflow/#set-upstream-branch", 
            "text": "You are creating branches locally. If you want to have the branch stored on GitHub so you can keep a backup, share your work, and submit pull requests for others to comment on your work, you need to push the branch to the repository and set it to track the branch upstream (meaning on GitHub).     Command  Description      git push --set-upstream origin  new-branch  Pushes the branch to the repository and tells Git to track it. Now,  new-branch  is a branch on your machine and on GitHub.     Tip You only have to use this command once. Afterwards,  git push  will know where to push the changes. When you are finished making changes to a file, you'll want to commit those changes. A file has three states in Git,  unstaged  (a file that has been changed but not staged),  staged  (a file that is ready to commit),  commited  (a file that is commited to the branch).", 
            "title": "Set upstream branch"
        }, 
        {
            "location": "/gitbashworkflow/#stage-and-commit", 
            "text": "Command  Description      git add  file-name  Takes a working file and stages it.    git commit -m \"some commit message\"  Commits the staged files and appends a commit message.    git add --all or git add .  Stages all unstaged working files.   A shortcut to staging each file individually.     Now that you have committed your files to your  new-branch , you'll want to update the branch in GitHub. So far, your git commits are only local commits.", 
            "title": "Stage and commit"
        }, 
        {
            "location": "/gitbashworkflow/#push-changes", 
            "text": "Command  Description      git push  Pushes your commits to the GitHub repo. If you did not push your branch before and set the origin to track your local branch, you'll receive a note in Git to  git push --set-upstream origin  new-branch . This command only works for branches that have upstream (in GitHub) branches.", 
            "title": "Push changes"
        }, 
        {
            "location": "/gitbashworkflow/#keep-in-mind", 
            "text": "When you are working on a file, you need to make sure that you are working on the appropriate branch. This is because Git changes your working directory based on the branch that you are on.  See  Branches  for a more detailed explanation of branches and working directory.", 
            "title": "Keep in mind"
        }, 
        {
            "location": "/gitbashworkflow/#staying-in-sync", 
            "text": "As many people are working in this omni-project, we'll need to make sure that our branches are up-to-date. It is good practice to grab any changes to your branch that have been pushed to the GitHub repo  before  you push your changes.     Command  Description      git pull  Fetches the changes from a remote branch and merges those changes with your local branch.    git fetch  Fetches the changes from a remote branch. fetch  as the changes to your local repository but does not merge them with your local branch.    git merge  new-branch  Whatever branch you are on, it will take  new-branch  and merge it.     It might be the case that you are working with a colleague who pushes a branch that they created to GitHub, and you want to see it on your machine. Let's say the branch is called  thors-branch . When you do  git branch  you don't see  thors-branch  because it hasn't been fetched from remote. You just have to  fetch  and then checkout the new branch.  git fetch\nFrom https://github.com/kyleweishaar/examples\n *  [ new branch ]         thors-branch -  origin/thors-branch\ngit checkout thors-branch", 
            "title": "Staying in sync"
        }, 
        {
            "location": "/sandbox/", 
            "text": "Sandbox Project\n\n\nWelcome to the sandbox environment. This repo contains one of the omni-project iterations that we can play with, without worrying about causing any irreversible problems. Use this repository for learning the many git operations. Make a bunch of branches. Create some merge conflicts. Reverse a commit. The sandbox is yours!\n\n\nPrerequisites\n\n\n\n\nHave a basic understanding of the basic git topics under \nLearn the basics\n on this site.\n\n\nHave Git, Git bash, and Sourcetree installed.\n\n\n\n\nLet's get started\n\n\nClone the sandbox repo.\n\n\n\n\nhttps://github.com/qlik-trial/help-doc-sandbox.git\n\n\n\n\nIf you need a reminder on how to clone the repo using Sourcetree, see \nClone the Project with Sourcetree\n.\n\n\nYou can use either Git bash or Sourcetree.\n\n\nRecommendation\nI recommend that you use Sourcetree. It is probably the tool you'll find most useful and intuitive for daily work, plus I am writing these tutorials from the perspective of Sourcetree!\nAfter you clone the repo, open Explorer and have a look around the folders. All of our projects are nested under \nContent\n. Each project is nested under its own folder. We have a single Flare project, many targets, many TOCs, and A LOT of topics. This is what the real omni project will look like (more or less).\n\n\nSourcetree\n\n\nWen you first open Sourcetree and the sandbox repo, it should look similar to this (perhaps a bit more graph elements).\n\n\n\n\nThe ribbon along the top gives you quick access to basic operations: \nmerge\n, \ncommit\n, \nbranch\n, \npush\n, and \npull\n. It also gives you the option to set up Git Flow (we may not implement this), you can open terminal, and your repo explorer.\n\n\nThe left-hand menu shows your file status, your local branches, your remote branches, your tags, and your stashes.\n\n\nThe three remaining window panes show the Git graph -- a visual representation of git branches and history. There is a file status area, and a file diff area where file changes are shown. These panes will become more familiar as we go through start-to-finish work examples.", 
            "title": "Sandbox Project"
        }, 
        {
            "location": "/sandbox/#sandbox-project", 
            "text": "Welcome to the sandbox environment. This repo contains one of the omni-project iterations that we can play with, without worrying about causing any irreversible problems. Use this repository for learning the many git operations. Make a bunch of branches. Create some merge conflicts. Reverse a commit. The sandbox is yours!", 
            "title": "Sandbox Project"
        }, 
        {
            "location": "/sandbox/#prerequisites", 
            "text": "Have a basic understanding of the basic git topics under  Learn the basics  on this site.  Have Git, Git bash, and Sourcetree installed.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/sandbox/#lets-get-started", 
            "text": "", 
            "title": "Let's get started"
        }, 
        {
            "location": "/sandbox/#clone-the-sandbox-repo", 
            "text": "https://github.com/qlik-trial/help-doc-sandbox.git   If you need a reminder on how to clone the repo using Sourcetree, see  Clone the Project with Sourcetree .  You can use either Git bash or Sourcetree.  Recommendation I recommend that you use Sourcetree. It is probably the tool you'll find most useful and intuitive for daily work, plus I am writing these tutorials from the perspective of Sourcetree! After you clone the repo, open Explorer and have a look around the folders. All of our projects are nested under  Content . Each project is nested under its own folder. We have a single Flare project, many targets, many TOCs, and A LOT of topics. This is what the real omni project will look like (more or less).", 
            "title": "Clone the sandbox repo."
        }, 
        {
            "location": "/sandbox/#sourcetree", 
            "text": "Wen you first open Sourcetree and the sandbox repo, it should look similar to this (perhaps a bit more graph elements).   The ribbon along the top gives you quick access to basic operations:  merge ,  commit ,  branch ,  push , and  pull . It also gives you the option to set up Git Flow (we may not implement this), you can open terminal, and your repo explorer.  The left-hand menu shows your file status, your local branches, your remote branches, your tags, and your stashes.  The three remaining window panes show the Git graph -- a visual representation of git branches and history. There is a file status area, and a file diff area where file changes are shown. These panes will become more familiar as we go through start-to-finish work examples.", 
            "title": "Sourcetree"
        }, 
        {
            "location": "/step1/", 
            "text": "Step 1 - Create, Add, Commit, Push\n\n\nLet's do a quick task that follows the centralized workflow. This will help you familiarize with the basic operations.\n\n\nA centralized workflow is more or less what we did with TFS.\n\n\nExercise\n\n\nLet's say that we only have a single branch called \nmaster\n (you might see other branches but ignore them for now). This branch is on the GitHub server and on your local machine. This workflow involves making changes locally and pushing them to the remote.\n\n\nOpen Sourcetree and look at your left-hand menu. It should show a master branch under \nBranches\n.\n\n\n\n\nDo the following:\n\n\nInfo\nIf there are other branches, make sure you are checkout on \nmaster\n. Master should be bold and have a circle beside it.\n\n\nOpen the omni-project in Flare (c/git/help-doc-sandbox) and create a new topic inside the \ntest-writers\n folder. Name it \"\nyour-name-test>\". It does not matter its content so just use a sample template or copy from another topic.\n\n\nAdd the new topic to the toc \ntest-writers-toc\n.\n\n\n\n\nOpen Sourcetree. Notice that Sourcetree placed the two files that you changed in the file staging area.\n\n\n\n\nYou'll see an \nuncommitted changes\n at the top of the graph.\n\n\nI've staged one file to show the unstaged and staged areas, but to stage a file you need to select it and stage it. \n\n\n\n\nTip\nRemember, files are one of three states: unstaged, staged, committed. When a file is new, git has not yet added it to the index so there can be no preview. Once you stage a new file, it is added to the index and you can preview the changes in the file content pane.\n\n\n\n\n\n\nStage all your files. (You sould have the topic and the toc).\n\n\n\n\nCommit your files with a message.\n\n\n\n\nDo a \ngit pull\n.\n\n\nTip\nWhen working in a repo with lots of contributors, you should \nalways\n pull before you push. This ensures that your copy of master is the latest. See \nBranching Best Practices\n.\n\n\n\n\nPush your commit to remote.\n\n\nInfo\nYou can select the checkbox that will push automatically with commit.\n\n\n\n\nCheck the graph.\n\n\n\n\nInfo\nIf you have the option \nShow Remote Branches\n selected, you'll see two more labels on the graph: \norigin/master\n and \norigin\\HEAD\n.\n\n\n\n\nLook around\n\n\nYou can click on commits in the Sourcetree graph to see the files and changes associated with each commit. Notice that comments can be very helpful when searching history.\n\n\nFor fun\n\n\nYou can open a previous version of a file. \n\n\n\n\nHighlight a commit in the graph (not the latest).\n\n\n\n\nRight-click on one of the files and select open previous version.\n\n\nYou'll notice that the file name is just a tempXXX number.\n\n\n\n\n\n\nIf you do this with an .htm file, it will open in your browser.", 
            "title": "Step 1 - Create, Add, Commit, Push"
        }, 
        {
            "location": "/step1/#step-1-create-add-commit-push", 
            "text": "Let's do a quick task that follows the centralized workflow. This will help you familiarize with the basic operations.  A centralized workflow is more or less what we did with TFS.", 
            "title": "Step 1 - Create, Add, Commit, Push"
        }, 
        {
            "location": "/step1/#exercise", 
            "text": "Let's say that we only have a single branch called  master  (you might see other branches but ignore them for now). This branch is on the GitHub server and on your local machine. This workflow involves making changes locally and pushing them to the remote.  Open Sourcetree and look at your left-hand menu. It should show a master branch under  Branches .   Do the following:  Info If there are other branches, make sure you are checkout on  master . Master should be bold and have a circle beside it.  Open the omni-project in Flare (c/git/help-doc-sandbox) and create a new topic inside the  test-writers  folder. Name it \" your-name-test>\". It does not matter its content so just use a sample template or copy from another topic.  Add the new topic to the toc  test-writers-toc .   Open Sourcetree. Notice that Sourcetree placed the two files that you changed in the file staging area.   You'll see an  uncommitted changes  at the top of the graph.  I've staged one file to show the unstaged and staged areas, but to stage a file you need to select it and stage it.    Tip Remember, files are one of three states: unstaged, staged, committed. When a file is new, git has not yet added it to the index so there can be no preview. Once you stage a new file, it is added to the index and you can preview the changes in the file content pane.    Stage all your files. (You sould have the topic and the toc).   Commit your files with a message.   Do a  git pull .  Tip When working in a repo with lots of contributors, you should  always  pull before you push. This ensures that your copy of master is the latest. See  Branching Best Practices .   Push your commit to remote.  Info You can select the checkbox that will push automatically with commit.   Check the graph.   Info If you have the option  Show Remote Branches  selected, you'll see two more labels on the graph:  origin/master  and  origin\\HEAD .", 
            "title": "Exercise"
        }, 
        {
            "location": "/step1/#look-around", 
            "text": "You can click on commits in the Sourcetree graph to see the files and changes associated with each commit. Notice that comments can be very helpful when searching history.", 
            "title": "Look around"
        }, 
        {
            "location": "/step1/#for-fun", 
            "text": "You can open a previous version of a file.    Highlight a commit in the graph (not the latest).   Right-click on one of the files and select open previous version.  You'll notice that the file name is just a tempXXX number.    If you do this with an .htm file, it will open in your browser.", 
            "title": "For fun"
        }, 
        {
            "location": "/step2/", 
            "text": "Step 2 - Branch, Add, Commit, Merge\n\n\nLet's make a branch! Branches are cheap and easy to make with git. In a system like TFS, branches are expensive, timely, and heavy. Why? Because a TFS branch is a copy of every single file in a branch. 100MB becomes 200MB.\n\n\nRecommendation\nGit is Simpler Than You Think\nExercise 1 - Branch and merge\n\n\nLet's assume that the repo hasn't changed since the end of step 1.\n\n\n\n\nWe have one branch \nmaster\n. We will branch off of the latest commit on \nmaster\n.\n\n\nDo the following:\n\n\n\n\n\n\nCreate a branch from \nmaster\n and name it \nfeature-\nname\n. If you need a reminder on how to branch, see \nCreate a Branch with Sourcetree\n. I created a branch called \nfeature-kyle\n.\n\n\n\n\nYou should see it pointing to the same commit as \nmaster\n.\n\n\nInfo\nRemember, a branch is just a pointer to a commit, and our new branch points to the same commit as \nmaster\n. This is why branches are cheap. Git does not create redundant files etc.\nNotice that the branch that is checked out is the new branch. This means any changes to files in my working directory are on this branch.\n\n\n\n\n\n\nOpen up the file you created in the last exercise and change the title and/or make some other changes.\n\n\n\n\nGo back to Sourcetree. You'll see \nuncommitted changes\n at the top of the graph.\n\n\n\n\nCommit the changes with a good commit message. If you see the TOC in the staged files, that is because the TOC entry is an xref link, so when you changed the title, the toc was also updated. Git picks up this change and puts your changed files in the staging area.\n\n\nInfo\nMake sure you do not push the changes to the remote. We did not setup remote tracking when we created this new branch so it only exists on your local machine.\n\n\n\n\n\n\nYour branch is now 1 commit ahead of \nmaster\n. Let's say the feature work is done and we want to merge our feature to \nmaster\n.\n\n\nDo the following:\n\n\n\n\nCheckout \nmaster\n.\n\n\nClick \nMerge\n from the ribbon.\n\n\nSelect the commit latest commit of your branch.\n\n\n\n\nLeave the default settings.\n\n\n\n\nInfo\nRemember, there were no other changes on \nmaster\n, so it does a fast-forward merge, which means \nmaster\n just moves to the latest commit.\n\n\n\n\nThe \nPush\n button indicates that you that the local \nmaster\n is ahead of the remote \nmaster\n. So go ahead and push!\n\n\nExercise 2 - Fix merge conflict\n\n\nLet's continue with a more complex example.\n\n\nInfo\nWhat I did for this example:\nI added an \nh2> and a \np> following the header. I did this for the same file on both branches. Next, I will merge the two branches. This will produce a merge conflict since both branches have changes in the same spot in the file.\nDo the following:\n\n\n\n\nCreate another branch from master. Call it \nfeature-\nname\n-2\n.\n\n\nCheck out the new branch.\n\n\nOpen your topic and add some Lorem Ipsum content.\n\n\nStage and commit this change to your current feature branch.\n\n\n\n\nCheckout \nfeature-\nname\n and repeat steps 3 and 4.\n\n\nInfo\nNotice that when you switch your branch, the changes you made to the topic on the other branch are no longer there. When you checkout a different branch, Git rebuilds the working directory based on that branch (which does not have the changes you just made).\n\n\nWe can see that from the commit that \nmaster\n points to, there are two branches for the feature branches. Three branches, all started from the same point, now all pointing to different commits. The topic file is different on each branch. \nmaster\n has the original version, the other two branches have different additions to the same topic. This could happen if two writers are working on the same file (feature files, TOCs, targets, etc.).\n\n\n\n\n\n\nClick \nMerge\n from the ribbon (we are still checkout on \nfeature-\nname\n).\n\n\n\n\nSelect the latest commit from the other feature branch (\nfeature-\nname\n-2\n) to merge into your current branch.\n\n\n\n\nYou should get a merge conflict, so select OK when the message pops up.\n\n\nSourcetree will look like this: the file with the merge conflict appears in both staging areas. This is because it has the \nfeature-\nname\n version in the \nstaged\n area and the \nfeature-\nname\n-2\n version in the \nunstaged\n area.\n\n\n\n\n\n\n\n\nSelect the staged file. You will see one staged hunk and one unstaged hunk. Open this file in your merge conflict tool, or a text editor.\n\n\nTip\nDid you set up a text editor yet?\n\n\n\n\nI use VS Code to see the conflict. It looks like this.\n\n\n\n\nThe file from \nfeature-\nname\n appear in green, and the file from \nfeature-\nname\n-2\n appears in blue. It is a conflict because the changes are in the same location in the file. I need to choose which file is correct, or merge the changes.\n\n\nVS Code gives the option to accept both changes, so I click Accept Both Changes. It places the first change above the other. I click save.\n\n\nTip\nIf you are using a text editor that does not have a built-in merge tool, you can simply delete the merge markup (=, \n, \n, HEAD) and organize the content how you like, then click save.\n\n\n\n\nGo back to Sourcetree.\n\n\n\n\n\n\nClick stage all, then commit with a message. Your conflict should be resolved.\n\n\n\n\nThere! I've merged my changes from \nfeature-\nname\n-2\n into \nfeature-\nname\n. I can safely delete \nfeature-\nname\n-2\n.\n\n\n\n\n\n\nCheckout \nmaster\n.\n\n\n\n\nClick \nMerge\n from the ribbon.\n\n\n\n\nSelect the merged commit that you made on the feature branch.\n\n\nNow \nmaster\n has the changes from the two feature branches.", 
            "title": "Step 2 - Branch, Add, Commit, Merge"
        }, 
        {
            "location": "/step2/#step-2-branch-add-commit-merge", 
            "text": "Let's make a branch! Branches are cheap and easy to make with git. In a system like TFS, branches are expensive, timely, and heavy. Why? Because a TFS branch is a copy of every single file in a branch. 100MB becomes 200MB.  Recommendation Git is Simpler Than You Think", 
            "title": "Step 2 - Branch, Add, Commit, Merge"
        }, 
        {
            "location": "/step2/#exercise-1-branch-and-merge", 
            "text": "Let's assume that the repo hasn't changed since the end of step 1.   We have one branch  master . We will branch off of the latest commit on  master .  Do the following:    Create a branch from  master  and name it  feature- name . If you need a reminder on how to branch, see  Create a Branch with Sourcetree . I created a branch called  feature-kyle .   You should see it pointing to the same commit as  master .  Info Remember, a branch is just a pointer to a commit, and our new branch points to the same commit as  master . This is why branches are cheap. Git does not create redundant files etc. Notice that the branch that is checked out is the new branch. This means any changes to files in my working directory are on this branch.    Open up the file you created in the last exercise and change the title and/or make some other changes.   Go back to Sourcetree. You'll see  uncommitted changes  at the top of the graph.   Commit the changes with a good commit message. If you see the TOC in the staged files, that is because the TOC entry is an xref link, so when you changed the title, the toc was also updated. Git picks up this change and puts your changed files in the staging area.  Info Make sure you do not push the changes to the remote. We did not setup remote tracking when we created this new branch so it only exists on your local machine.    Your branch is now 1 commit ahead of  master . Let's say the feature work is done and we want to merge our feature to  master .  Do the following:   Checkout  master .  Click  Merge  from the ribbon.  Select the commit latest commit of your branch.   Leave the default settings.   Info Remember, there were no other changes on  master , so it does a fast-forward merge, which means  master  just moves to the latest commit.   The  Push  button indicates that you that the local  master  is ahead of the remote  master . So go ahead and push!", 
            "title": "Exercise 1 - Branch and merge"
        }, 
        {
            "location": "/step2/#exercise-2-fix-merge-conflict", 
            "text": "Let's continue with a more complex example.  Info What I did for this example:\nI added an  h2> and a  p> following the header. I did this for the same file on both branches. Next, I will merge the two branches. This will produce a merge conflict since both branches have changes in the same spot in the file. Do the following:   Create another branch from master. Call it  feature- name -2 .  Check out the new branch.  Open your topic and add some Lorem Ipsum content.  Stage and commit this change to your current feature branch.   Checkout  feature- name  and repeat steps 3 and 4.  Info Notice that when you switch your branch, the changes you made to the topic on the other branch are no longer there. When you checkout a different branch, Git rebuilds the working directory based on that branch (which does not have the changes you just made).  We can see that from the commit that  master  points to, there are two branches for the feature branches. Three branches, all started from the same point, now all pointing to different commits. The topic file is different on each branch.  master  has the original version, the other two branches have different additions to the same topic. This could happen if two writers are working on the same file (feature files, TOCs, targets, etc.).    Click  Merge  from the ribbon (we are still checkout on  feature- name ).   Select the latest commit from the other feature branch ( feature- name -2 ) to merge into your current branch.   You should get a merge conflict, so select OK when the message pops up.  Sourcetree will look like this: the file with the merge conflict appears in both staging areas. This is because it has the  feature- name  version in the  staged  area and the  feature- name -2  version in the  unstaged  area.     Select the staged file. You will see one staged hunk and one unstaged hunk. Open this file in your merge conflict tool, or a text editor.  Tip Did you set up a text editor yet?   I use VS Code to see the conflict. It looks like this.   The file from  feature- name  appear in green, and the file from  feature- name -2  appears in blue. It is a conflict because the changes are in the same location in the file. I need to choose which file is correct, or merge the changes.  VS Code gives the option to accept both changes, so I click Accept Both Changes. It places the first change above the other. I click save.  Tip If you are using a text editor that does not have a built-in merge tool, you can simply delete the merge markup (=,  ,  , HEAD) and organize the content how you like, then click save.   Go back to Sourcetree.    Click stage all, then commit with a message. Your conflict should be resolved.   There! I've merged my changes from  feature- name -2  into  feature- name . I can safely delete  feature- name -2 .    Checkout  master .   Click  Merge  from the ribbon.   Select the merged commit that you made on the feature branch.  Now  master  has the changes from the two feature branches.", 
            "title": "Exercise 2 - Fix merge conflict"
        }, 
        {
            "location": "/gitbash-tips/", 
            "text": "Tips for Using Git Bash\n\n\nIf you don't have much experience using command-line, here are a couple of tips to help get you started.\n\n\nNavigating file directories\n\n\n\n\n\n\nTo move between directories, you use the \ncd\n command (the initialism stands for change directory).\n\n\n\n\n\n\nWhen you first open Git Bash, it opens in your home directory, which looks something like this:\n\n\nC:\n\\U\nsers\n\\%\nLocalUser%\n\n\n\n\n\n\n\n\nYou can move up to a parent folder by entering \n..\n. For example,\n\n\ncd\n ../../\n\n\n\n\ncd\n tells the shell to change the directory and the \n../../\n says to move up two levels (parent of LocalUser, then parent of Users). Now you are in the \nc\n directory.\n\n\nc/\n\n\n\n\n\n\n\n\nIt's easy to get lost in command-line.\n\n\n\n\n\n\nUse \npwd\n to print your working directory (where you are).\n\n\n\n\n\n\nList the contents of your current directory (the one you are in) by using \nls\n.\n\n\nThis command lists everything inside the folder.\n\n\n\n\n\n\nImportant commands for command-line navigation:\n\n\n\n\n\n\n\n\ncommand\n\n\nfunction\n\n\n\n\n\n\n\n\n\n\ncd\n\n\nchange directory\n\n\n\n\n\n\nls\n\n\nlist items in current directory\n\n\n\n\n\n\npwd\n\n\nshow the path of my current location\n\n\n\n\n\n\n\n\n\n\n\n\nChange the Git Bash default path\n\n\nIf you find it annoying to always have to \ncd ../../git/\nproject\n, you can change the starting location of Git Bash so that you open Git Bash at \ngit/\n.\n\n\n\n\nType Git Bash into your Windows search.\n\n\nRight-click on Git Bash, and select \nOpen File Location\n.\n    \nC:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Git\n\n\n\nRight-click on Git Bash, and select \nProperties\n.\n\n\nChange the value under \nStart\n:\n    \nC:\\git\n\n\n\nRemove the \n--cd-to-home\n part of the \nTarget\n value.\n\n\nClick \nApply\n.\n\n\n\n\nWhen you open Git Bash, it should start in your Git directory.\n\n\nTip\nAfter you change the starting path of Git Bash, pin it to your task bar.\nGit with Git Bash\n\n\nWhen you are in a git repository, you can run git commands.\n\n\nFor example, if you are in the omni-project repo (which is currently checked out on the master branch),\n\n\nBDM@usott-bdm MINGW64 /c/git/omni-project \n(\nmaster\n)\n\n\n\n\n\nyou can run git commands by specifying \ngit X\n, where X = the git operation.\n\n\ngit status\ngit branch\ngit --version\netc...\n\n\nIf you try to run git commands from a not-git directory, you'll get the following error:\n\n\nBDM@usott-bdm MINGW64 /c/git\n$ git status\nfatal: Not a git repository \n(\nor any of the parent directories\n)\n: .git", 
            "title": "Tips for Using Git Bash"
        }, 
        {
            "location": "/gitbash-tips/#tips-for-using-git-bash", 
            "text": "If you don't have much experience using command-line, here are a couple of tips to help get you started.", 
            "title": "Tips for Using Git Bash"
        }, 
        {
            "location": "/gitbash-tips/#navigating-file-directories", 
            "text": "To move between directories, you use the  cd  command (the initialism stands for change directory).    When you first open Git Bash, it opens in your home directory, which looks something like this:  C: \\U sers \\% LocalUser%    You can move up to a parent folder by entering  .. . For example,  cd  ../../  cd  tells the shell to change the directory and the  ../../  says to move up two levels (parent of LocalUser, then parent of Users). Now you are in the  c  directory.  c/", 
            "title": "Navigating file directories"
        }, 
        {
            "location": "/gitbash-tips/#its-easy-to-get-lost-in-command-line", 
            "text": "Use  pwd  to print your working directory (where you are).    List the contents of your current directory (the one you are in) by using  ls .  This command lists everything inside the folder.    Important commands for command-line navigation:     command  function      cd  change directory    ls  list items in current directory    pwd  show the path of my current location", 
            "title": "It's easy to get lost in command-line."
        }, 
        {
            "location": "/gitbash-tips/#change-the-git-bash-default-path", 
            "text": "If you find it annoying to always have to  cd ../../git/ project , you can change the starting location of Git Bash so that you open Git Bash at  git/ .   Type Git Bash into your Windows search.  Right-click on Git Bash, and select  Open File Location .\n     C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Git  Right-click on Git Bash, and select  Properties .  Change the value under  Start :\n     C:\\git  Remove the  --cd-to-home  part of the  Target  value.  Click  Apply .   When you open Git Bash, it should start in your Git directory.  Tip After you change the starting path of Git Bash, pin it to your task bar.", 
            "title": "Change the Git Bash default path"
        }, 
        {
            "location": "/gitbash-tips/#git-with-git-bash", 
            "text": "When you are in a git repository, you can run git commands.  For example, if you are in the omni-project repo (which is currently checked out on the master branch),  BDM@usott-bdm MINGW64 /c/git/omni-project  ( master )   you can run git commands by specifying  git X , where X = the git operation.  git status\ngit branch\ngit --version\netc... \nIf you try to run git commands from a not-git directory, you'll get the following error:  BDM@usott-bdm MINGW64 /c/git\n$ git status\nfatal: Not a git repository  ( or any of the parent directories ) : .git", 
            "title": "Git with Git Bash"
        }, 
        {
            "location": "/cheat-gitbash/", 
            "text": "Git Bash Cheat Sheet\n\n\nWanna use the command line? Walk trough the examples in this topic and bookmark this page for a quick reference to simple commands.\n\n\nBefore you begin\n\n\nRead the \nMoving to Git\n page.\n\n\nOn your local machine, \ncd\n to the git repo.\n\n\ncd\n git/omni-project\n\n\n\n\nInfo\nGit bash probably opens in the Home directory: \nuser/%localhost%\n. You can change this. Learn how with \nChange the Git Bash default path\nThe branch that you are on (checked out) is indicated in parentheses.\n\n\nBDM@usott-bdm MINGW64 /c/git/omni-project \n(\nmaster\n)\n\n\n\n\n\nBasic workflow and commands\n\n\nThe sections below follow a basic workflow of creating a branch, doing some work, and merging that branch.\n\n\nBasic commands\n\n\n\n\n\n\n\n\nCommand\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngit status\n\n\nShows the state of your current branch \n This is a very helpful tool to run after every command to see what state you're in.\n\n\n\n\n\n\ngit log\n\n\nShows a list of commits and metadata about those commits\n\n\n\n\n\n\ngit branch\n\n\nShows a list of branches\nThe current branch is marked with an (*)\n\n\n\n\n\n\n\n\nWhen you want to start working, you probably want to work on a new branch.\n\n\nBranching commands\n\n\nInfo\nnew-branch\n should be replaced by a name, no brackets or special characters, and no spaces.\n\n\n\n\n\n\nCommand\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngit branch \nnew-name\n\n\nCreates a new branch and assigns name to branch.\n\n\n\n\n\n\ngit checkout \nnew-name\n\n\nSwitches from current branch to new branch.\n\n\n\n\n\n\ngit checkout -b \nnew-branch\n\n\nCreates a new branch, assigns a name to it, and switches to it (checkout).\n\n\n\n\n\n\ngit branch -d \nnew-name\n\n\nDeletes the branch \nnew-name\n. \n You can't delete the branch that you are on.\n\n\n\n\n\n\n\n\nWhen you create a new branch, it is based on a copy of the branch that you are currently on. So, if you are on master, and you run \ngit branch \nnew-branch\n, then \nnew-branch\n is a copy of the latest commit on master.\n\n\nYou create branches locally. If you want to have the branch stored on GitHub so you can keep a backup, share your work, and submit pull requests for others to comment on your work, you need to push the branch to the repository and set it to track the branch upstream (meaning on GitHub).\n\n\nTrack the local branch on Gitub\n\n\n\n\n\n\n\n\nCommand\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngit push --set-upstream origin \nnew-branch\n\n\nPushes the branch to the repository and tells Git to track it. Now, \nnew-branch\n is a branch on your machine and on GitHub.\n\n\n\n\n\n\n\n\nTip\nYou only have to use this command once. Afterwards, \ngit push\n will know where to push the changes.\nStage and Commit commands\n\n\nChanges passed through a staging area. When you change a file, the changes are initially \nunstaged\n, you add them to the index so they become \nstaged\n, and then you commit then to the branch.\n\n\nInfo\nIt's 1990, and to store photos, you first get them developed and printed, spread out on the living room floor (unstaged). Once organized, you place them in a photo album, sorted in such as way that you can retrace your steps as your turn the pages (staged). The album looks great, so you label and date the spine, put it on the shelf, and wait for someone to ask \"How was your trip?\" (committed).\n\n\n\n\n\n\nCommand\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngit add \nfile-name\n\n\nTakes a working file and stages it.\n\n\n\n\n\n\ngit add --all\n\n\nStages all unstaged working files. \n A shortcut to staging each file individually.\n\n\n\n\n\n\ngit commit -m \"some commit message\"\n\n\nCommits the staged files and appends a commit message.\n\n\n\n\n\n\n\n\nNow that you have committed your files to your \nnew-branch\n, you'll want to update the branch in GitHub. So far, your git commits are only local commits.\n\n\nPush your commits\n\n\n\n\n\n\n\n\nCommand\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngit push\n\n\nPushes your commits to the GitHub repo.\nIf you didn't set the branch upstream, you'll receive a note in Git to \ngit push --set-upstream origin \nnew-branch\n. This command only works for branches that have upstream (in GitHub) branches.\n\n\n\n\n\n\n\n\nKeep in mind\n\n\nWhen you are working on a file, you need to make sure that you are working on the appropriate branch. This is because Git changes your working directory based on the branch that you are on.\n\n\nFor example, if you are on \nnew-branch\n and you change an \n.htm\n file in Flare, and then you switch to \nmaster\n, you'll notice that file changes back to the state it was in on \nmaster\n (it won't show the changes tat you did on \nnew-branch\n.\n\n\nA TFS branch is a copy of every single file. A git branch is a tiny reference object that points to a tree that points to individual blobs (files). Git only stores the new change and adds that change to the index.\n\n\nTo open a file on a branch in git, you just switch to that branch. The same working directory reflects the objects of the checked out branch.\n\n\nTo open a file on a branch in TFS, you navigate to the working directory where you have a copy of that branch. I have four release branches stored locally, each is a full copy. This is redundant * 4.\n\n\n\n\nKeeping in sync\n\n\nAs many people are working in this omni-project, we'll need to make sure that our branches are up-to-date. It is good practice to do a \ngit pull\n of \ngit fetch\n before you do a \ngit push\n.\n\n\n\n\n\n\n\n\nCommand\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngit pull\n\n\nPulls the contents of a branch from GitHub and merges it.\n\n\n\n\n\n\ngit fetch\n\n\nPulls the content of a branch from GitHub and \ndoesn't\n merge.\nIf you \nfecth\n then you'll have to manually \nmerge\n.\n\n\n\n\n\n\ngit merge \nnew-branch\n\n\nWhatever branch you are on, it will take \nnew-branch\n and merge it.\n\n\n\n\n\n\n\n\nWorking together\n\n\nLet's say your colleague Thor asks you for help on his new feature. He as his local branch and it is tracked on the remote GitHub server too. Let's say the branch is called \nthors-branch\n. When you do \ngit branch\n you don't see \nthors-branch\n because it hasn't been fetched from remote. You just have to fetch the remote and then checkout the new branch.\n\n\ngit fetch\nFrom https://github.com/qlik-trial/omni-project\n * \n[\nnew branch\n]\n        thors-branch -\n origin/thors-branch\ngit checkout \n`\nthors-branch\n`\n\n\n\n\n\nGit will fetch remote branches and list them for you so that you can then check it out.\n\n\nRevert a merge commit\n\n\nMade a mistake? That's ok. Use \ngit revert\n.\n\n\n\n\nSafe process.\n\n\nKeeps commit history.\n\n\nReverse the commit by creating a new commit.\n\n\n\n\nA--B--C\ngit revert (reverse C by committing D)\nA--B--C--D\n\n\n\n\n\n\nCheckout the branch you want to revert commit.\n\n\n\n\ngit checkout \nbranch\n\ngit pull origin/\nbranch\n\ngit revert -m \nrevert message\n \n1\n HEAD\n\n\n\n\nThis reverts the branch to the 1st parent. You can go back X number of commits by changing the argument.", 
            "title": "Git Bash cheat sheet"
        }, 
        {
            "location": "/cheat-gitbash/#git-bash-cheat-sheet", 
            "text": "Wanna use the command line? Walk trough the examples in this topic and bookmark this page for a quick reference to simple commands.", 
            "title": "Git Bash Cheat Sheet"
        }, 
        {
            "location": "/cheat-gitbash/#before-you-begin", 
            "text": "Read the  Moving to Git  page.  On your local machine,  cd  to the git repo.  cd  git/omni-project  Info Git bash probably opens in the Home directory:  user/%localhost% . You can change this. Learn how with  Change the Git Bash default path The branch that you are on (checked out) is indicated in parentheses.  BDM@usott-bdm MINGW64 /c/git/omni-project  ( master )", 
            "title": "Before you begin"
        }, 
        {
            "location": "/cheat-gitbash/#basic-workflow-and-commands", 
            "text": "The sections below follow a basic workflow of creating a branch, doing some work, and merging that branch.", 
            "title": "Basic workflow and commands"
        }, 
        {
            "location": "/cheat-gitbash/#basic-commands", 
            "text": "Command  Description      git status  Shows the state of your current branch   This is a very helpful tool to run after every command to see what state you're in.    git log  Shows a list of commits and metadata about those commits    git branch  Shows a list of branches The current branch is marked with an (*)     When you want to start working, you probably want to work on a new branch.", 
            "title": "Basic commands"
        }, 
        {
            "location": "/cheat-gitbash/#branching-commands", 
            "text": "Info new-branch  should be replaced by a name, no brackets or special characters, and no spaces.    Command  Description      git branch  new-name  Creates a new branch and assigns name to branch.    git checkout  new-name  Switches from current branch to new branch.    git checkout -b  new-branch  Creates a new branch, assigns a name to it, and switches to it (checkout).    git branch -d  new-name  Deletes the branch  new-name .   You can't delete the branch that you are on.     When you create a new branch, it is based on a copy of the branch that you are currently on. So, if you are on master, and you run  git branch  new-branch , then  new-branch  is a copy of the latest commit on master.  You create branches locally. If you want to have the branch stored on GitHub so you can keep a backup, share your work, and submit pull requests for others to comment on your work, you need to push the branch to the repository and set it to track the branch upstream (meaning on GitHub).", 
            "title": "Branching commands"
        }, 
        {
            "location": "/cheat-gitbash/#track-the-local-branch-on-gitub", 
            "text": "Command  Description      git push --set-upstream origin  new-branch  Pushes the branch to the repository and tells Git to track it. Now,  new-branch  is a branch on your machine and on GitHub.     Tip You only have to use this command once. Afterwards,  git push  will know where to push the changes.", 
            "title": "Track the local branch on Gitub"
        }, 
        {
            "location": "/cheat-gitbash/#stage-and-commit-commands", 
            "text": "Changes passed through a staging area. When you change a file, the changes are initially  unstaged , you add them to the index so they become  staged , and then you commit then to the branch.  Info It's 1990, and to store photos, you first get them developed and printed, spread out on the living room floor (unstaged). Once organized, you place them in a photo album, sorted in such as way that you can retrace your steps as your turn the pages (staged). The album looks great, so you label and date the spine, put it on the shelf, and wait for someone to ask \"How was your trip?\" (committed).    Command  Description      git add  file-name  Takes a working file and stages it.    git add --all  Stages all unstaged working files.   A shortcut to staging each file individually.    git commit -m \"some commit message\"  Commits the staged files and appends a commit message.     Now that you have committed your files to your  new-branch , you'll want to update the branch in GitHub. So far, your git commits are only local commits.", 
            "title": "Stage and Commit commands"
        }, 
        {
            "location": "/cheat-gitbash/#push-your-commits", 
            "text": "Command  Description      git push  Pushes your commits to the GitHub repo. If you didn't set the branch upstream, you'll receive a note in Git to  git push --set-upstream origin  new-branch . This command only works for branches that have upstream (in GitHub) branches.", 
            "title": "Push your commits"
        }, 
        {
            "location": "/cheat-gitbash/#keep-in-mind", 
            "text": "When you are working on a file, you need to make sure that you are working on the appropriate branch. This is because Git changes your working directory based on the branch that you are on.  For example, if you are on  new-branch  and you change an  .htm  file in Flare, and then you switch to  master , you'll notice that file changes back to the state it was in on  master  (it won't show the changes tat you did on  new-branch .  A TFS branch is a copy of every single file. A git branch is a tiny reference object that points to a tree that points to individual blobs (files). Git only stores the new change and adds that change to the index.  To open a file on a branch in git, you just switch to that branch. The same working directory reflects the objects of the checked out branch.  To open a file on a branch in TFS, you navigate to the working directory where you have a copy of that branch. I have four release branches stored locally, each is a full copy. This is redundant * 4.", 
            "title": "Keep in mind"
        }, 
        {
            "location": "/cheat-gitbash/#keeping-in-sync", 
            "text": "As many people are working in this omni-project, we'll need to make sure that our branches are up-to-date. It is good practice to do a  git pull  of  git fetch  before you do a  git push .     Command  Description      git pull  Pulls the contents of a branch from GitHub and merges it.    git fetch  Pulls the content of a branch from GitHub and  doesn't  merge. If you  fecth  then you'll have to manually  merge .    git merge  new-branch  Whatever branch you are on, it will take  new-branch  and merge it.", 
            "title": "Keeping in sync"
        }, 
        {
            "location": "/cheat-gitbash/#working-together", 
            "text": "Let's say your colleague Thor asks you for help on his new feature. He as his local branch and it is tracked on the remote GitHub server too. Let's say the branch is called  thors-branch . When you do  git branch  you don't see  thors-branch  because it hasn't been fetched from remote. You just have to fetch the remote and then checkout the new branch.  git fetch\nFrom https://github.com/qlik-trial/omni-project\n *  [ new branch ]         thors-branch -  origin/thors-branch\ngit checkout  ` thors-branch `   Git will fetch remote branches and list them for you so that you can then check it out.", 
            "title": "Working together"
        }, 
        {
            "location": "/cheat-gitbash/#revert-a-merge-commit", 
            "text": "Made a mistake? That's ok. Use  git revert .   Safe process.  Keeps commit history.  Reverse the commit by creating a new commit.   A--B--C\ngit revert (reverse C by committing D)\nA--B--C--D   Checkout the branch you want to revert commit.   git checkout  branch \ngit pull origin/ branch \ngit revert -m  revert message   1  HEAD  This reverts the branch to the 1st parent. You can go back X number of commits by changing the argument.", 
            "title": "Revert a merge commit"
        }, 
        {
            "location": "/branch-graph-gitExt/", 
            "text": "The Git Extension Graph\n\n\nWhen you open Git Extension, it looks something like this:\n\n\n\n\nWhen you first clone our documentation project (or any git repo), the first thing you'll notice a graph. This graph shows your commit history. Branches are indicated with labels that point to a commit. Each dot along the line is a previous commit with a commit message.\n\n\nYou can locate branches:\n\n\n\n\n\n\nIn the graph as labels beside commits.\n\n\n\n\n\n\nIn the branches drop-down menu in the second task bar.\n\n\n\n\n\n\nYou can toggle which branches show up in the graph under \nView\n.\n\n\nChecking commits\n\n\nThe commit history is important because it shows you what file(s) changed and what changed in the document.\n\n\nYou can click on a commit to bring up the commit details. There are 4 tabs:\n\n\n\n\n\n\n\n\nTab\n\n\nWhat you'll find under this tab\n\n\n\n\n\n\n\n\n\n\nCommit\n\n\nInfo about the commit, author, dates, SHA1, etc.\n\n\n\n\n\n\nFile tree\n\n\nA navigable file tree of the current repo.\n\n\n\n\n\n\nDiff\n\n\nThe differences added to the selected file in this commit.\n\n\n\n\n\n\nConsole\n\n\nA console to use command line.\n\n\n\n\n\n\n\n\n\n\nCommitting your work\n\n\nWhen you work on a file locally, git detects that the files in your working directory have changed, and it tracks those changes.\n\n\nInfo\nGit detects file changes when you click \nsave\n, for example, in Flare or in your text editor.\nIn the second menu bar, you will see an \nCommit\n button, sometimes it has a number beside it in parentheses. This number means that git has detected some file changes that you have not yet committed to the branch.\n\n\nWhen you work on files, they are added the working area and are currently unstaged. Before you add them to the repository, you need add them to the index by staging them.\n\n\nIn Git Extension, this looks like this:\n\n\n\n\nFiles in the red area are modified and in the working area. Files in the green area are modified and added to the index.\n\n\nThe actions that you'll need to do from this screen:\n\n\n\n\n\n\nStage a file using the down arrow.\n\n\n\n\n\n\nUnstage a file using the up arrow.\n\n\n\n\n\n\nAdd a commit message in the message area.\n\n\n\n\n\n\nCommit the files in the index to the repository.\n\n\n\n\n\n\nCommit and push files to the local and remote repositories.\n\n\n\n\n\n\nAfter you commit files to the repository, you can close this dialog. You'll see a new commit at the top of the graph with your commit message.\n\n\nCommitting locally but not pushing to remote\n\n\nFrom the main window, you can toggle your remote branches under \nView\n. In the screen capture below, I have toggled them ON (in red) so that they appear in the graph.\n\n\n\n\nNotice that they are pointing to previous commits, and importantly, different commits than their local counterparts. This means that my local \nmaster\n and \ndaily\n are out-of-sync with the remotes.\n\n\nTo push changes:\n\n\n\n\n\n\nUse the blue arrow to push changes to the remotes.\n\n\n\n\n\n\n\n\nThe default behaviour is to push the checked-out branch. You can also select the \nPush multiple branches\n tab to select more than one branch.\n\n\n\n\n\n\n\n\nNote that:\n\n\n\n\n\n\nOnly push shared branches.\n\n\n\n\n\n\nAll remotes are selected by default.\n\n\n\n\n\n\nForce rewind is the inverse of fast-forward merge, but it happens on the remote rather   than the local branch.\n\n\n\n\n\n\nChanges upstream\n\n\nWhat happens when someone else is working on the same branch as you, and they push their changes to \norigin/master\n while you have local changes committed but not pushed?\n\n\nWhen the remote and local branches diverge, the remote takes precedence in that we can't push changes to a remote if the history of the two branches is different. Git forces you to either \nfetch\n or \npull\n the changes from the remote before you \npush\n.\n\n\nIf you try to push first, Git Extension will throw this error.\n\n\n\n\nYou just need to do a \npull\n first. Select \nPull with last action\n.\n\n\nGit Extension will now do a \ngit pull\n followed by \ngit push\n. You will see the pull commit and the push commit on your graph.\n\n\n\n\nTip\n\n\nYou should get in the habit of running \ngit pull\n often and especially before you push to the remote.", 
            "title": "Git Extension Graph"
        }, 
        {
            "location": "/branch-graph-gitExt/#the-git-extension-graph", 
            "text": "When you open Git Extension, it looks something like this:   When you first clone our documentation project (or any git repo), the first thing you'll notice a graph. This graph shows your commit history. Branches are indicated with labels that point to a commit. Each dot along the line is a previous commit with a commit message.  You can locate branches:    In the graph as labels beside commits.    In the branches drop-down menu in the second task bar.    You can toggle which branches show up in the graph under  View .", 
            "title": "The Git Extension Graph"
        }, 
        {
            "location": "/branch-graph-gitExt/#checking-commits", 
            "text": "The commit history is important because it shows you what file(s) changed and what changed in the document.  You can click on a commit to bring up the commit details. There are 4 tabs:     Tab  What you'll find under this tab      Commit  Info about the commit, author, dates, SHA1, etc.    File tree  A navigable file tree of the current repo.    Diff  The differences added to the selected file in this commit.    Console  A console to use command line.", 
            "title": "Checking commits"
        }, 
        {
            "location": "/branch-graph-gitExt/#committing-your-work", 
            "text": "When you work on a file locally, git detects that the files in your working directory have changed, and it tracks those changes.  Info Git detects file changes when you click  save , for example, in Flare or in your text editor. In the second menu bar, you will see an  Commit  button, sometimes it has a number beside it in parentheses. This number means that git has detected some file changes that you have not yet committed to the branch.  When you work on files, they are added the working area and are currently unstaged. Before you add them to the repository, you need add them to the index by staging them.  In Git Extension, this looks like this:   Files in the red area are modified and in the working area. Files in the green area are modified and added to the index.  The actions that you'll need to do from this screen:    Stage a file using the down arrow.    Unstage a file using the up arrow.    Add a commit message in the message area.    Commit the files in the index to the repository.    Commit and push files to the local and remote repositories.    After you commit files to the repository, you can close this dialog. You'll see a new commit at the top of the graph with your commit message.", 
            "title": "Committing your work"
        }, 
        {
            "location": "/branch-graph-gitExt/#committing-locally-but-not-pushing-to-remote", 
            "text": "From the main window, you can toggle your remote branches under  View . In the screen capture below, I have toggled them ON (in red) so that they appear in the graph.   Notice that they are pointing to previous commits, and importantly, different commits than their local counterparts. This means that my local  master  and  daily  are out-of-sync with the remotes.  To push changes:    Use the blue arrow to push changes to the remotes.     The default behaviour is to push the checked-out branch. You can also select the  Push multiple branches  tab to select more than one branch.     Note that:    Only push shared branches.    All remotes are selected by default.    Force rewind is the inverse of fast-forward merge, but it happens on the remote rather   than the local branch.", 
            "title": "Committing locally but not pushing to remote"
        }, 
        {
            "location": "/branch-graph-gitExt/#changes-upstream", 
            "text": "What happens when someone else is working on the same branch as you, and they push their changes to  origin/master  while you have local changes committed but not pushed?  When the remote and local branches diverge, the remote takes precedence in that we can't push changes to a remote if the history of the two branches is different. Git forces you to either  fetch  or  pull  the changes from the remote before you  push .  If you try to push first, Git Extension will throw this error.   You just need to do a  pull  first. Select  Pull with last action .  Git Extension will now do a  git pull  followed by  git push . You will see the pull commit and the push commit on your graph.   Tip  You should get in the habit of running  git pull  often and especially before you push to the remote.", 
            "title": "Changes upstream"
        }, 
        {
            "location": "/gitterminology/", 
            "text": "Git Terminology\n\n\nComplete git glossary\n\n\n\n\n\n\n\n\nCommand\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbranch\n\n\nAn active area of development in Git. The tip of a branch is the most recent commit.\n\n\n\n\n\n\ncheckout\n\n\nTo take a commit from the repository and recreate the state of that commit (files and trees) in your working directory.\n\n\n\n\n\n\ncommit (n)\n\n\nA single point in the git history that holds the information about a changeset.\n\n\n\n\n\n\ncommit (v)\n\n\nTo store a new snapshot of state of your project in the git history. When you commit, you advance the HEAD.\n\n\n\n\n\n\nfetch\n\n\nTo find the latest changes in a branch from local and remote repo.\n\n\n\n\n\n\nhead\n\n\nA reference to the tip (commit) of a branch.\n\n\n\n\n\n\nlocal\n\n\nOn your machine.\n\n\n\n\n\n\nmerge\n\n\nTo bring the information from one branch into another.\n\n\n\n\n\n\nmaster\n\n\nThe default development branch \n There is nothing inherently special about master.\n\n\n\n\n\n\norigin\n\n\nThe default upstream repository (on GitHub). Origin is often the same as remote, but this is not necessarily.\n\n\n\n\n\n\npull request\n\n\nA request for suggestions/review regarding some commits to be merged.\n\n\n\n\n\n\npush\n\n\nTo push the changes after a commit.\n\n\n\n\n\n\nremote (repository)\n\n\nA repository that stored on the git server, and that is used to track your project. You push to the remote and pull/fetch from the remote.\n\n\n\n\n\n\nrepository\n\n\nA collection of commits, branches, objects, and tags.\n\n\n\n\n\n\nworking tree\n\n\nA representation of your tree and tree objects (your working directory).", 
            "title": "Git Terminology"
        }, 
        {
            "location": "/gitterminology/#git-terminology", 
            "text": "Complete git glossary     Command  Description      branch  An active area of development in Git. The tip of a branch is the most recent commit.    checkout  To take a commit from the repository and recreate the state of that commit (files and trees) in your working directory.    commit (n)  A single point in the git history that holds the information about a changeset.    commit (v)  To store a new snapshot of state of your project in the git history. When you commit, you advance the HEAD.    fetch  To find the latest changes in a branch from local and remote repo.    head  A reference to the tip (commit) of a branch.    local  On your machine.    merge  To bring the information from one branch into another.    master  The default development branch   There is nothing inherently special about master.    origin  The default upstream repository (on GitHub). Origin is often the same as remote, but this is not necessarily.    pull request  A request for suggestions/review regarding some commits to be merged.    push  To push the changes after a commit.    remote (repository)  A repository that stored on the git server, and that is used to track your project. You push to the remote and pull/fetch from the remote.    repository  A collection of commits, branches, objects, and tags.    working tree  A representation of your tree and tree objects (your working directory).", 
            "title": "Git Terminology"
        }, 
        {
            "location": "/about/", 
            "text": "About this website\n\n\nThe docs\n\n\nDocs are written in markdown. Docs are stored unders \n/docs\n. \n\n\nThe TOC\n\n\nTo add a doc to the website, you must include it in the \nyml\n file in the root directory.\n\n\nLocal build\n\n\nThe website is built with mkdocs. You can run the build locally by running \nmkdocs serve\n.\nThe webiste runs locally on http://127.0.0.1:8000/\n\n\nIf 8000 is busy, you specify the port number in the yml file.\n\n\ndev_addr: 127.0.0.1:\nyour-port-number\n\n\nTo deploy\n\n\nThe website is built from the \ngh-pages\n branch.\n\n\n\n\nWarning\n\n\nDo not make changes to this branch!\n\n\n\n\n\n\nCheckout master branch.\n\n\nRun \nmkdocs gh-pages\n to rebuild the site.\n    You do not need to merge \nmaster\n with \ngh-pages\n.", 
            "title": "About"
        }, 
        {
            "location": "/about/#about-this-website", 
            "text": "", 
            "title": "About this website"
        }, 
        {
            "location": "/about/#the-docs", 
            "text": "Docs are written in markdown. Docs are stored unders  /docs .", 
            "title": "The docs"
        }, 
        {
            "location": "/about/#the-toc", 
            "text": "To add a doc to the website, you must include it in the  yml  file in the root directory.", 
            "title": "The TOC"
        }, 
        {
            "location": "/about/#local-build", 
            "text": "The website is built with mkdocs. You can run the build locally by running  mkdocs serve .\nThe webiste runs locally on http://127.0.0.1:8000/  If 8000 is busy, you specify the port number in the yml file.  dev_addr: 127.0.0.1: your-port-number", 
            "title": "Local build"
        }, 
        {
            "location": "/about/#to-deploy", 
            "text": "The website is built from the  gh-pages  branch.   Warning  Do not make changes to this branch!    Checkout master branch.  Run  mkdocs gh-pages  to rebuild the site.\n    You do not need to merge  master  with  gh-pages .", 
            "title": "To deploy"
        }
    ]
}